/* wsrxC.cpp
   Generated by gSOAP 2.8.17r from ../../../../import/wsrm5.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "wsrxH.h"

SOAP_SOURCE_STAMP("@(#) wsrxC.cpp ver 2.8.17r 2014-03-16 20:04:42 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType:
		return soap_in_wsrm__IncompleteSequenceBehaviorType(soap, NULL, NULL, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_wsrm__FaultCodes:
		return soap_in_wsrm__FaultCodes(soap, NULL, NULL, "wsrm:FaultCodes");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wsrm__AcceptType:
		return soap_in_wsrm__AcceptType(soap, NULL, NULL, "wsrm:AcceptType");
	case SOAP_TYPE_wsrm__OfferType:
		return soap_in_wsrm__OfferType(soap, NULL, NULL, "wsrm:OfferType");
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return soap_in_wsrm__TerminateSequenceResponseType(soap, NULL, NULL, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return soap_in_wsrm__TerminateSequenceType(soap, NULL, NULL, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return soap_in_wsrm__CloseSequenceResponseType(soap, NULL, NULL, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return soap_in_wsrm__CloseSequenceType(soap, NULL, NULL, "wsrm:CloseSequenceType");
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return soap_in_wsrm__CreateSequenceResponseType(soap, NULL, NULL, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return soap_in_wsrm__CreateSequenceType(soap, NULL, NULL, "wsrm:CreateSequenceType");
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return soap_in_wsrm__SequenceFaultType(soap, NULL, NULL, "wsrm:SequenceFaultType");
	case SOAP_TYPE_wsrm__AckRequestedType:
		return soap_in_wsrm__AckRequestedType(soap, NULL, NULL, "wsrm:AckRequestedType");
	case SOAP_TYPE_wsrm__SequenceType:
		return soap_in_wsrm__SequenceType(soap, NULL, NULL, "wsrm:SequenceType");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, NULL, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		return soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, NULL, NULL, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		return soap_in_PointerTowsrm__TerminateSequenceType(soap, NULL, NULL, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		return soap_in_PointerTowsrm__CloseSequenceResponseType(soap, NULL, NULL, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		return soap_in_PointerTowsrm__CloseSequenceType(soap, NULL, NULL, "wsrm:CloseSequenceType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		return soap_in_PointerTowsrm__CreateSequenceResponseType(soap, NULL, NULL, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		return soap_in_PointerTowsrm__CreateSequenceType(soap, NULL, NULL, "wsrm:CreateSequenceType");
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		return soap_in_PointerTowsrm__SequenceFaultType(soap, NULL, NULL, "wsrm:SequenceFaultType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement(soap, NULL, NULL, "wsrm:SequenceAcknowledgement");
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		return soap_in_PointerTowsrm__AckRequestedType(soap, NULL, NULL, "wsrm:AckRequestedType");
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		return soap_in_PointerTowsrm__SequenceType(soap, NULL, NULL, "wsrm:SequenceType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, NULL, NULL, "wsrm:SequenceAcknowledgement-None");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, NULL, NULL, "wsrm:SequenceAcknowledgement-AcknowledgementRange");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		return soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, NULL, NULL, "wsrm:SequenceAcknowledgement-Final");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		return soap_in_PointerTowsrm__AcceptType(soap, NULL, NULL, "wsrm:AcceptType");
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		return soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, NULL, NULL, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_PointerTowsrm__OfferType:
		return soap_in_PointerTowsrm__OfferType(soap, NULL, NULL, "wsrm:OfferType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		return soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, NULL, NULL, "wsrm:UsesSequenceSSL");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, NULL, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:IncompleteSequenceBehaviorType"))
		{	*type = SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType;
			return soap_in_wsrm__IncompleteSequenceBehaviorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:FaultCodes"))
		{	*type = SOAP_TYPE_wsrm__FaultCodes;
			return soap_in_wsrm__FaultCodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:AcceptType"))
		{	*type = SOAP_TYPE_wsrm__AcceptType;
			return soap_in_wsrm__AcceptType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:OfferType"))
		{	*type = SOAP_TYPE_wsrm__OfferType;
			return soap_in_wsrm__OfferType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:TerminateSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__TerminateSequenceResponseType;
			return soap_in_wsrm__TerminateSequenceResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:TerminateSequenceType"))
		{	*type = SOAP_TYPE_wsrm__TerminateSequenceType;
			return soap_in_wsrm__TerminateSequenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CloseSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__CloseSequenceResponseType;
			return soap_in_wsrm__CloseSequenceResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CloseSequenceType"))
		{	*type = SOAP_TYPE_wsrm__CloseSequenceType;
			return soap_in_wsrm__CloseSequenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CreateSequenceResponseType"))
		{	*type = SOAP_TYPE_wsrm__CreateSequenceResponseType;
			return soap_in_wsrm__CreateSequenceResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:CreateSequenceType"))
		{	*type = SOAP_TYPE_wsrm__CreateSequenceType;
			return soap_in_wsrm__CreateSequenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceFaultType"))
		{	*type = SOAP_TYPE_wsrm__SequenceFaultType;
			return soap_in_wsrm__SequenceFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:AckRequestedType"))
		{	*type = SOAP_TYPE_wsrm__AckRequestedType;
			return soap_in_wsrm__AckRequestedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceType"))
		{	*type = SOAP_TYPE_wsrm__SequenceType;
			return soap_in_wsrm__SequenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-None"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_None;
			return soap_in__wsrm__SequenceAcknowledgement_None(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-AcknowledgementRange"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange;
			return soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement-Final"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement_Final;
			return soap_in__wsrm__SequenceAcknowledgement_Final(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:UsesSequenceSSL"))
		{	*type = SOAP_TYPE__wsrm__UsesSequenceSSL;
			return soap_in__wsrm__UsesSequenceSSL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:UsesSequenceSTR"))
		{	*type = SOAP_TYPE__wsrm__UsesSequenceSTR;
			return soap_in__wsrm__UsesSequenceSTR(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:SequenceAcknowledgement"))
		{	*type = SOAP_TYPE__wsrm__SequenceAcknowledgement;
			return soap_in__wsrm__SequenceAcknowledgement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsrm:Identifier"))
		{	char **s;
			*type = SOAP_TYPE__wsrm__Identifier;
			s = soap_in__wsrm__Identifier(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const LONG64 *)ptr, "xsd:duration");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, NULL);
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType:
		return soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag, id, (const enum wsrm__IncompleteSequenceBehaviorType *)ptr, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_wsrm__FaultCodes:
		return soap_out_wsrm__FaultCodes(soap, tag, id, (const enum wsrm__FaultCodes *)ptr, "wsrm:FaultCodes");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		return soap_out__wsrm__SequenceAcknowledgement_None(soap, "wsrm:SequenceAcknowledgement-None", id, (const struct _wsrm__SequenceAcknowledgement_None *)ptr, NULL);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:SequenceAcknowledgement-AcknowledgementRange", id, (const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)ptr, NULL);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		return soap_out__wsrm__SequenceAcknowledgement_Final(soap, "wsrm:SequenceAcknowledgement-Final", id, (const struct _wsrm__SequenceAcknowledgement_Final *)ptr, NULL);
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		return soap_out__wsrm__UsesSequenceSSL(soap, "wsrm:UsesSequenceSSL", id, (const struct _wsrm__UsesSequenceSSL *)ptr, NULL);
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		return soap_out__wsrm__UsesSequenceSTR(soap, "wsrm:UsesSequenceSTR", id, (const struct _wsrm__UsesSequenceSTR *)ptr, NULL);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		return soap_out__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", id, (const struct _wsrm__SequenceAcknowledgement *)ptr, NULL);
	case SOAP_TYPE_wsrm__AcceptType:
		return soap_out_wsrm__AcceptType(soap, tag, id, (const struct wsrm__AcceptType *)ptr, "wsrm:AcceptType");
	case SOAP_TYPE_wsrm__OfferType:
		return soap_out_wsrm__OfferType(soap, tag, id, (const struct wsrm__OfferType *)ptr, "wsrm:OfferType");
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return soap_out_wsrm__TerminateSequenceResponseType(soap, tag, id, (const struct wsrm__TerminateSequenceResponseType *)ptr, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return soap_out_wsrm__TerminateSequenceType(soap, tag, id, (const struct wsrm__TerminateSequenceType *)ptr, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return soap_out_wsrm__CloseSequenceResponseType(soap, tag, id, (const struct wsrm__CloseSequenceResponseType *)ptr, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return soap_out_wsrm__CloseSequenceType(soap, tag, id, (const struct wsrm__CloseSequenceType *)ptr, "wsrm:CloseSequenceType");
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return soap_out_wsrm__CreateSequenceResponseType(soap, tag, id, (const struct wsrm__CreateSequenceResponseType *)ptr, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return soap_out_wsrm__CreateSequenceType(soap, tag, id, (const struct wsrm__CreateSequenceType *)ptr, "wsrm:CreateSequenceType");
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return soap_out_wsrm__SequenceFaultType(soap, tag, id, (const struct wsrm__SequenceFaultType *)ptr, "wsrm:SequenceFaultType");
	case SOAP_TYPE_wsrm__AckRequestedType:
		return soap_out_wsrm__AckRequestedType(soap, tag, id, (const struct wsrm__AckRequestedType *)ptr, "wsrm:AckRequestedType");
	case SOAP_TYPE_wsrm__SequenceType:
		return soap_out_wsrm__SequenceType(soap, tag, id, (const struct wsrm__SequenceType *)ptr, "wsrm:SequenceType");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, NULL);
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, NULL);
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, NULL);
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		return soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, tag, id, (struct wsrm__TerminateSequenceResponseType *const*)ptr, "wsrm:TerminateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		return soap_out_PointerTowsrm__TerminateSequenceType(soap, tag, id, (struct wsrm__TerminateSequenceType *const*)ptr, "wsrm:TerminateSequenceType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		return soap_out_PointerTowsrm__CloseSequenceResponseType(soap, tag, id, (struct wsrm__CloseSequenceResponseType *const*)ptr, "wsrm:CloseSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		return soap_out_PointerTowsrm__CloseSequenceType(soap, tag, id, (struct wsrm__CloseSequenceType *const*)ptr, "wsrm:CloseSequenceType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		return soap_out_PointerTowsrm__CreateSequenceResponseType(soap, tag, id, (struct wsrm__CreateSequenceResponseType *const*)ptr, "wsrm:CreateSequenceResponseType");
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		return soap_out_PointerTowsrm__CreateSequenceType(soap, tag, id, (struct wsrm__CreateSequenceType *const*)ptr, "wsrm:CreateSequenceType");
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		return soap_out_PointerTowsrm__SequenceFaultType(soap, tag, id, (struct wsrm__SequenceFaultType *const*)ptr, "wsrm:SequenceFaultType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement(soap, tag, id, (struct _wsrm__SequenceAcknowledgement *const*)ptr, "wsrm:SequenceAcknowledgement");
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		return soap_out_PointerTowsrm__AckRequestedType(soap, tag, id, (struct wsrm__AckRequestedType *const*)ptr, "wsrm:AckRequestedType");
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		return soap_out_PointerTowsrm__SequenceType(soap, tag, id, (struct wsrm__SequenceType *const*)ptr, "wsrm:SequenceType");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_None *const*)ptr, "wsrm:SequenceAcknowledgement-None");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*)ptr, "wsrm:SequenceAcknowledgement-AcknowledgementRange");
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		return soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag, id, (struct _wsrm__SequenceAcknowledgement_Final *const*)ptr, "wsrm:SequenceAcknowledgement-Final");
	case SOAP_TYPE_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		return soap_out_PointerTowsrm__AcceptType(soap, tag, id, (struct wsrm__AcceptType *const*)ptr, "wsrm:AcceptType");
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		return soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag, id, (enum wsrm__IncompleteSequenceBehaviorType *const*)ptr, "wsrm:IncompleteSequenceBehaviorType");
	case SOAP_TYPE_PointerTowsrm__OfferType:
		return soap_out_PointerTowsrm__OfferType(soap, tag, id, (struct wsrm__OfferType *const*)ptr, "wsrm:OfferType");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (LONG64 *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		return soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, tag, id, (struct _wsrm__UsesSequenceSSL *const*)ptr, "wsrm:UsesSequenceSSL");
	case SOAP_TYPE__wsrm__Identifier:
		return soap_out_string(soap, "wsrm:Identifier", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___wsrm__LastMessage:
		soap_serialize___wsrm__LastMessage(soap, (const struct __wsrm__LastMessage *)ptr);
		break;
	case SOAP_TYPE___wsrm__AckRequested:
		soap_serialize___wsrm__AckRequested(soap, (const struct __wsrm__AckRequested *)ptr);
		break;
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		soap_serialize___wsrm__SequenceAcknowledgement(soap, (const struct __wsrm__SequenceAcknowledgement *)ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		soap_serialize___wsrm__TerminateSequenceResponse(soap, (const struct __wsrm__TerminateSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		soap_serialize___wsrm__CloseSequenceResponse(soap, (const struct __wsrm__CloseSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		soap_serialize___wsrm__CreateSequenceResponse(soap, (const struct __wsrm__CreateSequenceResponse *)ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequence:
		soap_serialize___wsrm__TerminateSequence(soap, (const struct __wsrm__TerminateSequence *)ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequence:
		soap_serialize___wsrm__CloseSequence(soap, (const struct __wsrm__CloseSequence *)ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequence:
		soap_serialize___wsrm__CreateSequence(soap, (const struct __wsrm__CreateSequence *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		soap_serialize__wsrm__SequenceAcknowledgement_None(soap, (const struct _wsrm__SequenceAcknowledgement_None *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, (const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		soap_serialize__wsrm__SequenceAcknowledgement_Final(soap, (const struct _wsrm__SequenceAcknowledgement_Final *)ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		soap_serialize__wsrm__UsesSequenceSSL(soap, (const struct _wsrm__UsesSequenceSSL *)ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		soap_serialize__wsrm__UsesSequenceSTR(soap, (const struct _wsrm__UsesSequenceSTR *)ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		soap_serialize__wsrm__SequenceAcknowledgement(soap, (const struct _wsrm__SequenceAcknowledgement *)ptr);
		break;
	case SOAP_TYPE_wsrm__AcceptType:
		soap_serialize_wsrm__AcceptType(soap, (const struct wsrm__AcceptType *)ptr);
		break;
	case SOAP_TYPE_wsrm__OfferType:
		soap_serialize_wsrm__OfferType(soap, (const struct wsrm__OfferType *)ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		soap_serialize_wsrm__TerminateSequenceResponseType(soap, (const struct wsrm__TerminateSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		soap_serialize_wsrm__TerminateSequenceType(soap, (const struct wsrm__TerminateSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		soap_serialize_wsrm__CloseSequenceResponseType(soap, (const struct wsrm__CloseSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceType:
		soap_serialize_wsrm__CloseSequenceType(soap, (const struct wsrm__CloseSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		soap_serialize_wsrm__CreateSequenceResponseType(soap, (const struct wsrm__CreateSequenceResponseType *)ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceType:
		soap_serialize_wsrm__CreateSequenceType(soap, (const struct wsrm__CreateSequenceType *)ptr);
		break;
	case SOAP_TYPE_wsrm__SequenceFaultType:
		soap_serialize_wsrm__SequenceFaultType(soap, (const struct wsrm__SequenceFaultType *)ptr);
		break;
	case SOAP_TYPE_wsrm__AckRequestedType:
		soap_serialize_wsrm__AckRequestedType(soap, (const struct wsrm__AckRequestedType *)ptr);
		break;
	case SOAP_TYPE_wsrm__SequenceType:
		soap_serialize_wsrm__SequenceType(soap, (const struct wsrm__SequenceType *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType:
		soap_serialize_PointerTowsrm__TerminateSequenceResponseType(soap, (struct wsrm__TerminateSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__TerminateSequenceType:
		soap_serialize_PointerTowsrm__TerminateSequenceType(soap, (struct wsrm__TerminateSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType:
		soap_serialize_PointerTowsrm__CloseSequenceResponseType(soap, (struct wsrm__CloseSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CloseSequenceType:
		soap_serialize_PointerTowsrm__CloseSequenceType(soap, (struct wsrm__CloseSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType:
		soap_serialize_PointerTowsrm__CreateSequenceResponseType(soap, (struct wsrm__CreateSequenceResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__CreateSequenceType:
		soap_serialize_PointerTowsrm__CreateSequenceType(soap, (struct wsrm__CreateSequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__SequenceFaultType:
		soap_serialize_PointerTowsrm__SequenceFaultType(soap, (struct wsrm__SequenceFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement(soap, (struct _wsrm__SequenceAcknowledgement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__AckRequestedType:
		soap_serialize_PointerTowsrm__AckRequestedType(soap, (struct wsrm__AckRequestedType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__SequenceType:
		soap_serialize_PointerTowsrm__SequenceType(soap, (struct wsrm__SequenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(soap, (struct _wsrm__SequenceAcknowledgement_None *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final:
		soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, (struct _wsrm__SequenceAcknowledgement_Final *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__AcceptType:
		soap_serialize_PointerTowsrm__AcceptType(soap, (struct wsrm__AcceptType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType:
		soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, (enum wsrm__IncompleteSequenceBehaviorType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsrm__OfferType:
		soap_serialize_PointerTowsrm__OfferType(soap, (struct wsrm__OfferType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL:
		soap_serialize_PointerTo_wsrm__UsesSequenceSSL(soap, (struct _wsrm__UsesSequenceSSL *const*)ptr);
		break;
	case SOAP_TYPE__wsrm__Identifier:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 wsrx_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_wsrm__SequenceType:
		return (void*)soap_instantiate_wsrm__SequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__AckRequestedType:
		return (void*)soap_instantiate_wsrm__AckRequestedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__SequenceFaultType:
		return (void*)soap_instantiate_wsrm__SequenceFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CreateSequenceType:
		return (void*)soap_instantiate_wsrm__CreateSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		return (void*)soap_instantiate_wsrm__CreateSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CloseSequenceType:
		return (void*)soap_instantiate_wsrm__CloseSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		return (void*)soap_instantiate_wsrm__CloseSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		return (void*)soap_instantiate_wsrm__TerminateSequenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		return (void*)soap_instantiate_wsrm__TerminateSequenceResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__OfferType:
		return (void*)soap_instantiate_wsrm__OfferType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsrm__AcceptType:
		return (void*)soap_instantiate_wsrm__AcceptType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_Final(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement_None(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		return (void*)soap_instantiate__wsrm__SequenceAcknowledgement(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		return (void*)soap_instantiate__wsrm__UsesSequenceSTR(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		return (void*)soap_instantiate__wsrm__UsesSequenceSSL(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CreateSequence:
		return (void*)soap_instantiate___wsrm__CreateSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CloseSequence:
		return (void*)soap_instantiate___wsrm__CloseSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__TerminateSequence:
		return (void*)soap_instantiate___wsrm__TerminateSequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		return (void*)soap_instantiate___wsrm__CreateSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		return (void*)soap_instantiate___wsrm__CloseSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		return (void*)soap_instantiate___wsrm__TerminateSequenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		return (void*)soap_instantiate___wsrm__SequenceAcknowledgement(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__AckRequested:
		return (void*)soap_instantiate___wsrm__AckRequested(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsrm__LastMessage:
		return (void*)soap_instantiate___wsrm__LastMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 wsrx_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE((struct chan__ChannelInstanceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct chan__ChannelInstanceType*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_wsrm__SequenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__SequenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__SequenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__AckRequestedType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__AckRequestedType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__AckRequestedType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__SequenceFaultType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__SequenceFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__SequenceFaultType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__CreateSequenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__CreateSequenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__CreateSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__CreateSequenceResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__CreateSequenceResponseType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__CloseSequenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__CloseSequenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__CloseSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__CloseSequenceResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__CloseSequenceResponseType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__TerminateSequenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__TerminateSequenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__TerminateSequenceResponseType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__TerminateSequenceResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__TerminateSequenceResponseType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__OfferType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__OfferType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__OfferType*)p->ptr);
		break;
	case SOAP_TYPE_wsrm__AcceptType:
		if (p->size < 0)
			SOAP_DELETE((struct wsrm__AcceptType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsrm__AcceptType*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_Final:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__SequenceAcknowledgement_Final*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__SequenceAcknowledgement_Final*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement_None:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__SequenceAcknowledgement_None*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__SequenceAcknowledgement_None*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__SequenceAcknowledgement:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__SequenceAcknowledgement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__SequenceAcknowledgement*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSTR:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__UsesSequenceSTR*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__UsesSequenceSTR*)p->ptr);
		break;
	case SOAP_TYPE__wsrm__UsesSequenceSSL:
		if (p->size < 0)
			SOAP_DELETE((struct _wsrm__UsesSequenceSSL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsrm__UsesSequenceSSL*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequence:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__CreateSequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__CreateSequence*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequence:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__CloseSequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__CloseSequence*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequence:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__TerminateSequence*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__TerminateSequence*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__CreateSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__CreateSequenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__CreateSequenceResponse*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__CloseSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__CloseSequenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__CloseSequenceResponse*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__TerminateSequenceResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__TerminateSequenceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__TerminateSequenceResponse*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__SequenceAcknowledgement:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__SequenceAcknowledgement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__SequenceAcknowledgement*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__AckRequested:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__AckRequested*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__AckRequested*)p->ptr);
		break;
	case SOAP_TYPE___wsrm__LastMessage:
		if (p->size < 0)
			SOAP_DELETE((struct __wsrm__LastMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __wsrm__LastMessage*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, wsrx_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsrm__IncompleteSequenceBehaviorType
	*a = SOAP_DEFAULT_wsrm__IncompleteSequenceBehaviorType;
#else
	*a = (enum wsrm__IncompleteSequenceBehaviorType)0;
#endif
}

static const struct soap_code_map soap_codes_wsrm__IncompleteSequenceBehaviorType[] =
{	{ (long)DiscardEntireSequence, "DiscardEntireSequence" },
	{ (long)DiscardFollowingFirstGap, "DiscardFollowingFirstGap" },
	{ (long)NoDiscard, "NoDiscard" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsrm__IncompleteSequenceBehaviorType2s(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType n)
{	const char *s = soap_code_str(soap_codes_wsrm__IncompleteSequenceBehaviorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, int id, const enum wsrm__IncompleteSequenceBehaviorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType), type) || soap_send(soap, soap_wsrm__IncompleteSequenceBehaviorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *s, enum wsrm__IncompleteSequenceBehaviorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsrm__IncompleteSequenceBehaviorType, s);
	if (map)
		*a = (enum wsrm__IncompleteSequenceBehaviorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsrm__IncompleteSequenceBehaviorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType * SOAP_FMAC4 soap_in_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, enum wsrm__IncompleteSequenceBehaviorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsrm__IncompleteSequenceBehaviorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, sizeof(enum wsrm__IncompleteSequenceBehaviorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsrm__IncompleteSequenceBehaviorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsrm__IncompleteSequenceBehaviorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, 0, sizeof(enum wsrm__IncompleteSequenceBehaviorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, const enum wsrm__IncompleteSequenceBehaviorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType);
	if (soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag?tag:"wsrm:IncompleteSequenceBehaviorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType * SOAP_FMAC4 soap_get_wsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__FaultCodes(struct soap *soap, enum wsrm__FaultCodes *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsrm__FaultCodes
	*a = SOAP_DEFAULT_wsrm__FaultCodes;
#else
	*a = (enum wsrm__FaultCodes)0;
#endif
}

static const struct soap_code_map soap_codes_wsrm__FaultCodes[] =
{	{ (long)wsrm__SequenceTerminated, "wsrm:SequenceTerminated" },
	{ (long)wsrm__UnknownSequence, "wsrm:UnknownSequence" },
	{ (long)wsrm__InvalidAcknowledgement, "wsrm:InvalidAcknowledgement" },
	{ (long)wsrm__MessageNumberRollover, "wsrm:MessageNumberRollover" },
	{ (long)wsrm__LastMessageNumberExceeded, "wsrm:LastMessageNumberExceeded" },
	{ (long)wsrm__CreateSequenceRefused, "wsrm:CreateSequenceRefused" },
	{ (long)wsrm__WSRMRequired, "wsrm:WSRMRequired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsrm__FaultCodes2s(struct soap *soap, enum wsrm__FaultCodes n)
{	const char *s = soap_code_str(soap_codes_wsrm__FaultCodes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__FaultCodes(struct soap *soap, const char *tag, int id, const enum wsrm__FaultCodes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__FaultCodes), type) || soap_send(soap, soap_wsrm__FaultCodes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsrm__FaultCodes(struct soap *soap, const char *s, enum wsrm__FaultCodes *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsrm__FaultCodes, t);
	if (map)
		*a = (enum wsrm__FaultCodes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsrm__FaultCodes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsrm__FaultCodes * SOAP_FMAC4 soap_in_wsrm__FaultCodes(struct soap *soap, const char *tag, enum wsrm__FaultCodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsrm__FaultCodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__FaultCodes, sizeof(enum wsrm__FaultCodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsrm__FaultCodes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsrm__FaultCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__FaultCodes, 0, sizeof(enum wsrm__FaultCodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__FaultCodes(struct soap *soap, const enum wsrm__FaultCodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__FaultCodes);
	if (soap_out_wsrm__FaultCodes(soap, tag?tag:"wsrm:FaultCodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__FaultCodes * SOAP_FMAC4 soap_get_wsrm__FaultCodes(struct soap *soap, enum wsrm__FaultCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__FaultCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
	*a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
	*a = (enum _wsa5__IsReferenceParameter)0;
#endif
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (long)_wsa5__IsReferenceParameter__false, "false" },
	{ (long)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, 0, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__IsReferenceParameter);
	if (soap_out__wsa5__IsReferenceParameter(soap, tag?tag:"wsa5:IsReferenceParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
	*a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
	*a = (enum wsa5__FaultCodesType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (long)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (long)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (long)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (long)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (long)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (long)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (long)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (long)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (long)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (long)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (long)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, 0, sizeof(enum wsa5__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesType);
	if (soap_out_wsa5__FaultCodesType(soap, tag?tag:"wsa5:FaultCodesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
	*a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
	*a = (enum wsa5__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (long)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, 0, sizeof(enum wsa5__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipType);
	if (soap_out_wsa5__RelationshipType(soap, tag?tag:"wsa5:RelationshipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__LastMessage(struct soap *soap, struct __wsrm__LastMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__LastMessage(struct soap *soap, const struct __wsrm__LastMessage *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__LastMessage(struct soap *soap, const char *tag, int id, const struct __wsrm__LastMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__LastMessage * SOAP_FMAC4 soap_in___wsrm__LastMessage(struct soap *soap, const char *tag, struct __wsrm__LastMessage *a, const char *type)
{
	a = (struct __wsrm__LastMessage *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__LastMessage, sizeof(struct __wsrm__LastMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__LastMessage(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__LastMessage(struct soap *soap, const struct __wsrm__LastMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__LastMessage(soap, tag?tag:"-wsrm:LastMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__LastMessage * SOAP_FMAC4 soap_get___wsrm__LastMessage(struct soap *soap, struct __wsrm__LastMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__LastMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__LastMessage * SOAP_FMAC2 soap_instantiate___wsrm__LastMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__LastMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__LastMessage, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__LastMessage);
		if (size)
			*size = sizeof(struct __wsrm__LastMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__LastMessage, n);
		if (size)
			*size = n * sizeof(struct __wsrm__LastMessage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__LastMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__LastMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__LastMessage %p -> %p\n", q, p));
	*(struct __wsrm__LastMessage*)p = *(struct __wsrm__LastMessage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__AckRequested(struct soap *soap, struct __wsrm__AckRequested *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__AckRequested(struct soap *soap, const struct __wsrm__AckRequested *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__AckRequested(struct soap *soap, const char *tag, int id, const struct __wsrm__AckRequested *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__AckRequested * SOAP_FMAC4 soap_in___wsrm__AckRequested(struct soap *soap, const char *tag, struct __wsrm__AckRequested *a, const char *type)
{
	a = (struct __wsrm__AckRequested *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__AckRequested, sizeof(struct __wsrm__AckRequested), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__AckRequested(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__AckRequested(struct soap *soap, const struct __wsrm__AckRequested *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__AckRequested(soap, tag?tag:"-wsrm:AckRequested", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__AckRequested * SOAP_FMAC4 soap_get___wsrm__AckRequested(struct soap *soap, struct __wsrm__AckRequested *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__AckRequested(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__AckRequested * SOAP_FMAC2 soap_instantiate___wsrm__AckRequested(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__AckRequested(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__AckRequested, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__AckRequested);
		if (size)
			*size = sizeof(struct __wsrm__AckRequested);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__AckRequested, n);
		if (size)
			*size = n * sizeof(struct __wsrm__AckRequested);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__AckRequested*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__AckRequested(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__AckRequested %p -> %p\n", q, p));
	*(struct __wsrm__AckRequested*)p = *(struct __wsrm__AckRequested*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__SequenceAcknowledgement(struct soap *soap, struct __wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__SequenceAcknowledgement(struct soap *soap, const struct __wsrm__SequenceAcknowledgement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, const struct __wsrm__SequenceAcknowledgement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_in___wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct __wsrm__SequenceAcknowledgement *a, const char *type)
{
	a = (struct __wsrm__SequenceAcknowledgement *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__SequenceAcknowledgement, sizeof(struct __wsrm__SequenceAcknowledgement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__SequenceAcknowledgement(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__SequenceAcknowledgement(struct soap *soap, const struct __wsrm__SequenceAcknowledgement *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__SequenceAcknowledgement(soap, tag?tag:"-wsrm:SequenceAcknowledgement", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_get___wsrm__SequenceAcknowledgement(struct soap *soap, struct __wsrm__SequenceAcknowledgement *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate___wsrm__SequenceAcknowledgement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__SequenceAcknowledgement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__SequenceAcknowledgement, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__SequenceAcknowledgement);
		if (size)
			*size = sizeof(struct __wsrm__SequenceAcknowledgement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__SequenceAcknowledgement, n);
		if (size)
			*size = n * sizeof(struct __wsrm__SequenceAcknowledgement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__SequenceAcknowledgement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__SequenceAcknowledgement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__SequenceAcknowledgement %p -> %p\n", q, p));
	*(struct __wsrm__SequenceAcknowledgement*)p = *(struct __wsrm__SequenceAcknowledgement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__TerminateSequenceResponse(struct soap *soap, struct __wsrm__TerminateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__TerminateSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__TerminateSequenceResponse(struct soap *soap, const struct __wsrm__TerminateSequenceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__TerminateSequenceResponseType(soap, &a->wsrm__TerminateSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__TerminateSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__TerminateSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, "wsrm:TerminateSequenceResponse", -1, &a->wsrm__TerminateSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC4 soap_in___wsrm__TerminateSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__TerminateSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__TerminateSequenceResponse = 1;
	short soap_flag;
	a = (struct __wsrm__TerminateSequenceResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__TerminateSequenceResponse, sizeof(struct __wsrm__TerminateSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__TerminateSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__TerminateSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, "wsrm:TerminateSequenceResponse", &a->wsrm__TerminateSequenceResponse, "wsrm:TerminateSequenceResponseType"))
				{	soap_flag_wsrm__TerminateSequenceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__TerminateSequenceResponse(struct soap *soap, const struct __wsrm__TerminateSequenceResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__TerminateSequenceResponse(soap, tag?tag:"-wsrm:TerminateSequenceResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC4 soap_get___wsrm__TerminateSequenceResponse(struct soap *soap, struct __wsrm__TerminateSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__TerminateSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__TerminateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__TerminateSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__TerminateSequenceResponse, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__TerminateSequenceResponse);
		if (size)
			*size = sizeof(struct __wsrm__TerminateSequenceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__TerminateSequenceResponse, n);
		if (size)
			*size = n * sizeof(struct __wsrm__TerminateSequenceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__TerminateSequenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__TerminateSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__TerminateSequenceResponse %p -> %p\n", q, p));
	*(struct __wsrm__TerminateSequenceResponse*)p = *(struct __wsrm__TerminateSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CloseSequenceResponse(struct soap *soap, struct __wsrm__CloseSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CloseSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CloseSequenceResponse(struct soap *soap, const struct __wsrm__CloseSequenceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__CloseSequenceResponseType(soap, &a->wsrm__CloseSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CloseSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__CloseSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__CloseSequenceResponseType(soap, "wsrm:CloseSequenceResponse", -1, &a->wsrm__CloseSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequenceResponse * SOAP_FMAC4 soap_in___wsrm__CloseSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__CloseSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__CloseSequenceResponse = 1;
	short soap_flag;
	a = (struct __wsrm__CloseSequenceResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CloseSequenceResponse, sizeof(struct __wsrm__CloseSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CloseSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CloseSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__CloseSequenceResponseType(soap, "wsrm:CloseSequenceResponse", &a->wsrm__CloseSequenceResponse, "wsrm:CloseSequenceResponseType"))
				{	soap_flag_wsrm__CloseSequenceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CloseSequenceResponse(struct soap *soap, const struct __wsrm__CloseSequenceResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__CloseSequenceResponse(soap, tag?tag:"-wsrm:CloseSequenceResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequenceResponse * SOAP_FMAC4 soap_get___wsrm__CloseSequenceResponse(struct soap *soap, struct __wsrm__CloseSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CloseSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__CloseSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CloseSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__CloseSequenceResponse, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__CloseSequenceResponse);
		if (size)
			*size = sizeof(struct __wsrm__CloseSequenceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__CloseSequenceResponse, n);
		if (size)
			*size = n * sizeof(struct __wsrm__CloseSequenceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__CloseSequenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__CloseSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__CloseSequenceResponse %p -> %p\n", q, p));
	*(struct __wsrm__CloseSequenceResponse*)p = *(struct __wsrm__CloseSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CreateSequenceResponse(struct soap *soap, struct __wsrm__CreateSequenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CreateSequenceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CreateSequenceResponse(struct soap *soap, const struct __wsrm__CreateSequenceResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__CreateSequenceResponseType(soap, &a->wsrm__CreateSequenceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CreateSequenceResponse(struct soap *soap, const char *tag, int id, const struct __wsrm__CreateSequenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__CreateSequenceResponseType(soap, "wsrm:CreateSequenceResponse", -1, &a->wsrm__CreateSequenceResponse, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequenceResponse * SOAP_FMAC4 soap_in___wsrm__CreateSequenceResponse(struct soap *soap, const char *tag, struct __wsrm__CreateSequenceResponse *a, const char *type)
{
	size_t soap_flag_wsrm__CreateSequenceResponse = 1;
	short soap_flag;
	a = (struct __wsrm__CreateSequenceResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CreateSequenceResponse, sizeof(struct __wsrm__CreateSequenceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CreateSequenceResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CreateSequenceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__CreateSequenceResponseType(soap, "wsrm:CreateSequenceResponse", &a->wsrm__CreateSequenceResponse, "wsrm:CreateSequenceResponseType"))
				{	soap_flag_wsrm__CreateSequenceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CreateSequenceResponse(struct soap *soap, const struct __wsrm__CreateSequenceResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__CreateSequenceResponse(soap, tag?tag:"-wsrm:CreateSequenceResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequenceResponse * SOAP_FMAC4 soap_get___wsrm__CreateSequenceResponse(struct soap *soap, struct __wsrm__CreateSequenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CreateSequenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__CreateSequenceResponse * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CreateSequenceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__CreateSequenceResponse, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__CreateSequenceResponse);
		if (size)
			*size = sizeof(struct __wsrm__CreateSequenceResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__CreateSequenceResponse, n);
		if (size)
			*size = n * sizeof(struct __wsrm__CreateSequenceResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__CreateSequenceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__CreateSequenceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__CreateSequenceResponse %p -> %p\n", q, p));
	*(struct __wsrm__CreateSequenceResponse*)p = *(struct __wsrm__CreateSequenceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__TerminateSequence(struct soap *soap, struct __wsrm__TerminateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__TerminateSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__TerminateSequence(struct soap *soap, const struct __wsrm__TerminateSequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__TerminateSequenceType(soap, &a->wsrm__TerminateSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__TerminateSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__TerminateSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__TerminateSequenceType(soap, "wsrm:TerminateSequence", -1, &a->wsrm__TerminateSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequence * SOAP_FMAC4 soap_in___wsrm__TerminateSequence(struct soap *soap, const char *tag, struct __wsrm__TerminateSequence *a, const char *type)
{
	size_t soap_flag_wsrm__TerminateSequence = 1;
	short soap_flag;
	a = (struct __wsrm__TerminateSequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__TerminateSequence, sizeof(struct __wsrm__TerminateSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__TerminateSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__TerminateSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__TerminateSequenceType(soap, "wsrm:TerminateSequence", &a->wsrm__TerminateSequence, "wsrm:TerminateSequenceType"))
				{	soap_flag_wsrm__TerminateSequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__TerminateSequence(struct soap *soap, const struct __wsrm__TerminateSequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__TerminateSequence(soap, tag?tag:"-wsrm:TerminateSequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__TerminateSequence * SOAP_FMAC4 soap_get___wsrm__TerminateSequence(struct soap *soap, struct __wsrm__TerminateSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__TerminateSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__TerminateSequence * SOAP_FMAC2 soap_instantiate___wsrm__TerminateSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__TerminateSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__TerminateSequence, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__TerminateSequence);
		if (size)
			*size = sizeof(struct __wsrm__TerminateSequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__TerminateSequence, n);
		if (size)
			*size = n * sizeof(struct __wsrm__TerminateSequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__TerminateSequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__TerminateSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__TerminateSequence %p -> %p\n", q, p));
	*(struct __wsrm__TerminateSequence*)p = *(struct __wsrm__TerminateSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CloseSequence(struct soap *soap, struct __wsrm__CloseSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CloseSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CloseSequence(struct soap *soap, const struct __wsrm__CloseSequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__CloseSequenceType(soap, &a->wsrm__CloseSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CloseSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__CloseSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__CloseSequenceType(soap, "wsrm:CloseSequence", -1, &a->wsrm__CloseSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequence * SOAP_FMAC4 soap_in___wsrm__CloseSequence(struct soap *soap, const char *tag, struct __wsrm__CloseSequence *a, const char *type)
{
	size_t soap_flag_wsrm__CloseSequence = 1;
	short soap_flag;
	a = (struct __wsrm__CloseSequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CloseSequence, sizeof(struct __wsrm__CloseSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CloseSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CloseSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__CloseSequenceType(soap, "wsrm:CloseSequence", &a->wsrm__CloseSequence, "wsrm:CloseSequenceType"))
				{	soap_flag_wsrm__CloseSequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CloseSequence(struct soap *soap, const struct __wsrm__CloseSequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__CloseSequence(soap, tag?tag:"-wsrm:CloseSequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CloseSequence * SOAP_FMAC4 soap_get___wsrm__CloseSequence(struct soap *soap, struct __wsrm__CloseSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CloseSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__CloseSequence * SOAP_FMAC2 soap_instantiate___wsrm__CloseSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CloseSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__CloseSequence, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__CloseSequence);
		if (size)
			*size = sizeof(struct __wsrm__CloseSequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__CloseSequence, n);
		if (size)
			*size = n * sizeof(struct __wsrm__CloseSequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__CloseSequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__CloseSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__CloseSequence %p -> %p\n", q, p));
	*(struct __wsrm__CloseSequence*)p = *(struct __wsrm__CloseSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsrm__CreateSequence(struct soap *soap, struct __wsrm__CreateSequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsrm__CreateSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsrm__CreateSequence(struct soap *soap, const struct __wsrm__CreateSequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsrm__CreateSequenceType(soap, &a->wsrm__CreateSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsrm__CreateSequence(struct soap *soap, const char *tag, int id, const struct __wsrm__CreateSequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsrm__CreateSequenceType(soap, "wsrm:CreateSequence", -1, &a->wsrm__CreateSequence, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequence * SOAP_FMAC4 soap_in___wsrm__CreateSequence(struct soap *soap, const char *tag, struct __wsrm__CreateSequence *a, const char *type)
{
	size_t soap_flag_wsrm__CreateSequence = 1;
	short soap_flag;
	a = (struct __wsrm__CreateSequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsrm__CreateSequence, sizeof(struct __wsrm__CreateSequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsrm__CreateSequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrm__CreateSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__CreateSequenceType(soap, "wsrm:CreateSequence", &a->wsrm__CreateSequence, "wsrm:CreateSequenceType"))
				{	soap_flag_wsrm__CreateSequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsrm__CreateSequence(struct soap *soap, const struct __wsrm__CreateSequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsrm__CreateSequence(soap, tag?tag:"-wsrm:CreateSequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsrm__CreateSequence * SOAP_FMAC4 soap_get___wsrm__CreateSequence(struct soap *soap, struct __wsrm__CreateSequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsrm__CreateSequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsrm__CreateSequence * SOAP_FMAC2 soap_instantiate___wsrm__CreateSequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsrm__CreateSequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsrm__CreateSequence, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsrm__CreateSequence);
		if (size)
			*size = sizeof(struct __wsrm__CreateSequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsrm__CreateSequence, n);
		if (size)
			*size = n * sizeof(struct __wsrm__CreateSequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsrm__CreateSequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsrm__CreateSequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsrm__CreateSequence %p -> %p\n", q, p));
	*(struct __wsrm__CreateSequence*)p = *(struct __wsrm__CreateSequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_None(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_None *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_None *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_None *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__SequenceAcknowledgement_None *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, sizeof(struct _wsrm__SequenceAcknowledgement_None), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_None(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_None *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, 0, sizeof(struct _wsrm__SequenceAcknowledgement_None), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_None(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_None *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__SequenceAcknowledgement_None);
	if (soap_out__wsrm__SequenceAcknowledgement_None(soap, tag?tag:"wsrm:SequenceAcknowledgement-None", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_None(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_None * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_None(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_None(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__SequenceAcknowledgement_None);
		if (size)
			*size = sizeof(struct _wsrm__SequenceAcknowledgement_None);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__SequenceAcknowledgement_None, n);
		if (size)
			*size = n * sizeof(struct _wsrm__SequenceAcknowledgement_None);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__SequenceAcknowledgement_None*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__SequenceAcknowledgement_None(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__SequenceAcknowledgement_None %p -> %p\n", q, p));
	*(struct _wsrm__SequenceAcknowledgement_None*)p = *(struct _wsrm__SequenceAcknowledgement_None*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedLONG64(soap, &a->Upper);
	soap_default_unsignedLONG64(soap, &a->Lower);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *type)
{
	soap_set_attr(soap, "Upper", soap_ULONG642s(soap, a->Upper), 1);
	soap_set_attr(soap, "Lower", soap_ULONG642s(soap, a->Lower), 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a);
	if (soap_s2ULONG64(soap, soap_attr_value(soap, "Upper", 1), &a->Upper))
		return NULL;
	if (soap_s2ULONG64(soap, soap_attr_value(soap, "Lower", 1), &a->Lower))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, 0, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange);
	if (soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag?tag:"wsrm:SequenceAcknowledgement-AcknowledgementRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_AcknowledgementRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
		if (size)
			*size = sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange, n);
		if (size)
			*size = n * sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__SequenceAcknowledgement_AcknowledgementRange %p -> %p\n", q, p));
	*(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)p = *(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_Final *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement_Final *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_Final *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__SequenceAcknowledgement_Final *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, sizeof(struct _wsrm__SequenceAcknowledgement_Final), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement_Final(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_Final *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, 0, sizeof(struct _wsrm__SequenceAcknowledgement_Final), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement_Final(struct soap *soap, const struct _wsrm__SequenceAcknowledgement_Final *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final);
	if (soap_out__wsrm__SequenceAcknowledgement_Final(soap, tag?tag:"wsrm:SequenceAcknowledgement-Final", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement_Final(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement_Final * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement_Final(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement_Final(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__SequenceAcknowledgement_Final);
		if (size)
			*size = sizeof(struct _wsrm__SequenceAcknowledgement_Final);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__SequenceAcknowledgement_Final, n);
		if (size)
			*size = n * sizeof(struct _wsrm__SequenceAcknowledgement_Final);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__SequenceAcknowledgement_Final*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__SequenceAcknowledgement_Final(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__SequenceAcknowledgement_Final %p -> %p\n", q, p));
	*(struct _wsrm__SequenceAcknowledgement_Final*)p = *(struct _wsrm__SequenceAcknowledgement_Final*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__UsesSequenceSSL(struct soap *soap, const struct _wsrm__UsesSequenceSSL *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, int id, const struct _wsrm__UsesSequenceSSL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__UsesSequenceSSL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL * SOAP_FMAC4 soap_in__wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSSL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__UsesSequenceSSL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__UsesSequenceSSL, sizeof(struct _wsrm__UsesSequenceSSL), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__UsesSequenceSSL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSSL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__UsesSequenceSSL, 0, sizeof(struct _wsrm__UsesSequenceSSL), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__UsesSequenceSSL(struct soap *soap, const struct _wsrm__UsesSequenceSSL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__UsesSequenceSSL);
	if (soap_out__wsrm__UsesSequenceSSL(soap, tag?tag:"wsrm:UsesSequenceSSL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL * SOAP_FMAC4 soap_get__wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__UsesSequenceSSL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__UsesSequenceSSL * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSSL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__UsesSequenceSSL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__UsesSequenceSSL, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__UsesSequenceSSL);
		if (size)
			*size = sizeof(struct _wsrm__UsesSequenceSSL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__UsesSequenceSSL, n);
		if (size)
			*size = n * sizeof(struct _wsrm__UsesSequenceSSL);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__UsesSequenceSSL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__UsesSequenceSSL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__UsesSequenceSSL %p -> %p\n", q, p));
	*(struct _wsrm__UsesSequenceSSL*)p = *(struct _wsrm__UsesSequenceSSL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__UsesSequenceSTR(struct soap *soap, struct _wsrm__UsesSequenceSTR *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__UsesSequenceSTR(struct soap *soap, const struct _wsrm__UsesSequenceSTR *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__UsesSequenceSTR(struct soap *soap, const char *tag, int id, const struct _wsrm__UsesSequenceSTR *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__UsesSequenceSTR), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSTR * SOAP_FMAC4 soap_in__wsrm__UsesSequenceSTR(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSTR *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__UsesSequenceSTR *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__UsesSequenceSTR, sizeof(struct _wsrm__UsesSequenceSTR), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__UsesSequenceSTR(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSTR *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__UsesSequenceSTR, 0, sizeof(struct _wsrm__UsesSequenceSTR), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__UsesSequenceSTR(struct soap *soap, const struct _wsrm__UsesSequenceSTR *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__UsesSequenceSTR);
	if (soap_out__wsrm__UsesSequenceSTR(soap, tag?tag:"wsrm:UsesSequenceSTR", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSTR * SOAP_FMAC4 soap_get__wsrm__UsesSequenceSTR(struct soap *soap, struct _wsrm__UsesSequenceSTR *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__UsesSequenceSTR(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__UsesSequenceSTR * SOAP_FMAC2 soap_instantiate__wsrm__UsesSequenceSTR(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__UsesSequenceSTR(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__UsesSequenceSTR, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__UsesSequenceSTR);
		if (size)
			*size = sizeof(struct _wsrm__UsesSequenceSTR);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__UsesSequenceSTR, n);
		if (size)
			*size = n * sizeof(struct _wsrm__UsesSequenceSTR);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__UsesSequenceSTR*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__UsesSequenceSTR(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__UsesSequenceSTR %p -> %p\n", q, p));
	*(struct _wsrm__UsesSequenceSTR*)p = *(struct _wsrm__UsesSequenceSTR*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	a->__sizeNack = 0;
	a->Nack = NULL;
	a->Final = NULL;
	a->__sizeAcknowledgementRange = 0;
	a->AcknowledgementRange = NULL;
	a->None = NULL;
	a->netrm__BufferRemaining = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrm__SequenceAcknowledgement(struct soap *soap, const struct _wsrm__SequenceAcknowledgement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	if (a->Nack)
	{	int i;
		for (i = 0; i < a->__sizeNack; i++)
		{
			soap_embedded(soap, a->Nack + i, SOAP_TYPE_unsignedLONG64);
		}
	}
	soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, &a->Final);
	if (a->AcknowledgementRange)
	{	int i;
		for (i = 0; i < a->__sizeAcknowledgementRange; i++)
		{
			soap_embedded(soap, a->AcknowledgementRange + i, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange);
			soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a->AcknowledgementRange + i);
		}
	}
	soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(soap, &a->None);
	soap_serialize_PointerToint(soap, &a->netrm__BufferRemaining);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, const struct _wsrm__SequenceAcknowledgement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	if (a->Nack)
	{	int i;
		for (i = 0; i < a->__sizeNack; i++)
			if (soap_out_unsignedLONG64(soap, "wsrm:Nack", -1, a->Nack + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, "wsrm:Final", -1, &a->Final, ""))
		return soap->error;
	if (a->AcknowledgementRange)
	{	int i;
		for (i = 0; i < a->__sizeAcknowledgementRange; i++)
			if (soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:AcknowledgementRange", -1, a->AcknowledgementRange + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, "wsrm:None", -1, &a->None, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "netrm:BufferRemaining", -1, &a->netrm__BufferRemaining, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_in__wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	struct soap_blist *soap_blist_Nack = NULL;
	size_t soap_flag_Final = 1;
	struct soap_blist *soap_blist_AcknowledgementRange = NULL;
	size_t soap_flag_None = 1;
	size_t soap_flag_netrm__BufferRemaining = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrm__SequenceAcknowledgement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrm__SequenceAcknowledgement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:Nack", 1, NULL))
			{	if (a->Nack == NULL)
				{	if (soap_blist_Nack == NULL)
						soap_blist_Nack = soap_new_block(soap);
					a->Nack = (ULONG64 *)soap_push_block(soap, soap_blist_Nack, sizeof(ULONG64));
					if (a->Nack == NULL)
						return NULL;
					soap_default_unsignedLONG64(soap, a->Nack);
				}
				soap_revert(soap);
				if (soap_in_unsignedLONG64(soap, "wsrm:Nack", a->Nack, "xsd:unsignedLong"))
				{	a->__sizeNack++;
					a->Nack = NULL;
					continue;
				}
			}
			if (soap_flag_Final && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, "wsrm:Final", &a->Final, ""))
				{	soap_flag_Final--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:AcknowledgementRange", 1, NULL))
			{	if (a->AcknowledgementRange == NULL)
				{	if (soap_blist_AcknowledgementRange == NULL)
						soap_blist_AcknowledgementRange = soap_new_block(soap);
					a->AcknowledgementRange = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)soap_push_block(soap, soap_blist_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange));
					if (a->AcknowledgementRange == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->AcknowledgementRange, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange);
					soap_default__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, a->AcknowledgementRange);
				}
				soap_revert(soap);
				if (soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, "wsrm:AcknowledgementRange", a->AcknowledgementRange, ""))
				{	a->__sizeAcknowledgementRange++;
					a->AcknowledgementRange = NULL;
					continue;
				}
			}
			if (soap_flag_None && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, "wsrm:None", &a->None, ""))
				{	soap_flag_None--;
					continue;
				}
			if (soap_flag_netrm__BufferRemaining && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "netrm:BufferRemaining", &a->netrm__BufferRemaining, "xsd:int"))
				{	soap_flag_netrm__BufferRemaining--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Nack)
			soap_pop_block(soap, soap_blist_Nack);
		if (a->__sizeNack)
			a->Nack = (ULONG64 *)soap_save_block(soap, soap_blist_Nack, NULL, 1);
		else
		{	a->Nack = NULL;
			if (soap_blist_Nack)
				soap_end_block(soap, soap_blist_Nack);
		}
		if (a->AcknowledgementRange)
			soap_pop_block(soap, soap_blist_AcknowledgementRange);
		if (a->__sizeAcknowledgementRange)
			a->AcknowledgementRange = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *)soap_save_block(soap, soap_blist_AcknowledgementRange, NULL, 1);
		else
		{	a->AcknowledgementRange = NULL;
			if (soap_blist_AcknowledgementRange)
				soap_end_block(soap, soap_blist_AcknowledgementRange);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrm__SequenceAcknowledgement, 0, sizeof(struct _wsrm__SequenceAcknowledgement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrm__SequenceAcknowledgement(struct soap *soap, const struct _wsrm__SequenceAcknowledgement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsrm__SequenceAcknowledgement);
	if (soap_out__wsrm__SequenceAcknowledgement(soap, tag?tag:"wsrm:SequenceAcknowledgement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC4 soap_get__wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsrm__SequenceAcknowledgement * SOAP_FMAC2 soap_instantiate__wsrm__SequenceAcknowledgement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsrm__SequenceAcknowledgement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsrm__SequenceAcknowledgement, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsrm__SequenceAcknowledgement);
		if (size)
			*size = sizeof(struct _wsrm__SequenceAcknowledgement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsrm__SequenceAcknowledgement, n);
		if (size)
			*size = n * sizeof(struct _wsrm__SequenceAcknowledgement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsrm__SequenceAcknowledgement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsrm__SequenceAcknowledgement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsrm__SequenceAcknowledgement %p -> %p\n", q, p));
	*(struct _wsrm__SequenceAcknowledgement*)p = *(struct _wsrm__SequenceAcknowledgement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->AcksTo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__AcceptType(struct soap *soap, const struct wsrm__AcceptType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->AcksTo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__AcceptType(struct soap *soap, const char *tag, int id, const struct wsrm__AcceptType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__AcceptType), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", -1, &a->AcksTo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__AcceptType * SOAP_FMAC4 soap_in_wsrm__AcceptType(struct soap *soap, const char *tag, struct wsrm__AcceptType *a, const char *type)
{
	size_t soap_flag_AcksTo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__AcceptType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__AcceptType, sizeof(struct wsrm__AcceptType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__AcceptType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcksTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", &a->AcksTo, "wsa5:EndpointReferenceType"))
				{	soap_flag_AcksTo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__AcceptType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__AcceptType, 0, sizeof(struct wsrm__AcceptType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AcksTo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__AcceptType(struct soap *soap, const struct wsrm__AcceptType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__AcceptType);
	if (soap_out_wsrm__AcceptType(soap, tag?tag:"wsrm:AcceptType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AcceptType * SOAP_FMAC4 soap_get_wsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__AcceptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__AcceptType * SOAP_FMAC2 soap_instantiate_wsrm__AcceptType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__AcceptType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__AcceptType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__AcceptType);
		if (size)
			*size = sizeof(struct wsrm__AcceptType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__AcceptType, n);
		if (size)
			*size = n * sizeof(struct wsrm__AcceptType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__AcceptType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__AcceptType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__AcceptType %p -> %p\n", q, p));
	*(struct wsrm__AcceptType*)p = *(struct wsrm__AcceptType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__OfferType(struct soap *soap, struct wsrm__OfferType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	soap_default_wsa5__EndpointReferenceType(soap, &a->Endpoint);
	a->Expires = NULL;
	a->IncompleteSequenceBehavior = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__OfferType(struct soap *soap, const struct wsrm__OfferType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->Endpoint);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, &a->IncompleteSequenceBehavior);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__OfferType(struct soap *soap, const char *tag, int id, const struct wsrm__OfferType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__OfferType), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:Endpoint", -1, &a->Endpoint, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", -1, &a->IncompleteSequenceBehavior, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__OfferType * SOAP_FMAC4 soap_in_wsrm__OfferType(struct soap *soap, const char *tag, struct wsrm__OfferType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Endpoint = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_IncompleteSequenceBehavior = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__OfferType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__OfferType, sizeof(struct wsrm__OfferType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__OfferType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:Endpoint", &a->Endpoint, "wsa5:EndpointReferenceType"))
				{	soap_flag_Endpoint--;
					continue;
				}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap_flag_IncompleteSequenceBehavior && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", &a->IncompleteSequenceBehavior, "wsrm:IncompleteSequenceBehaviorType"))
				{	soap_flag_IncompleteSequenceBehavior--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__OfferType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__OfferType, 0, sizeof(struct wsrm__OfferType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0 || soap_flag_Endpoint > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__OfferType(struct soap *soap, const struct wsrm__OfferType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__OfferType);
	if (soap_out_wsrm__OfferType(soap, tag?tag:"wsrm:OfferType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__OfferType * SOAP_FMAC4 soap_get_wsrm__OfferType(struct soap *soap, struct wsrm__OfferType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__OfferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__OfferType * SOAP_FMAC2 soap_instantiate_wsrm__OfferType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__OfferType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__OfferType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__OfferType);
		if (size)
			*size = sizeof(struct wsrm__OfferType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__OfferType, n);
		if (size)
			*size = n * sizeof(struct wsrm__OfferType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__OfferType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__OfferType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__OfferType %p -> %p\n", q, p));
	*(struct wsrm__OfferType*)p = *(struct wsrm__OfferType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__TerminateSequenceResponseType(struct soap *soap, const struct wsrm__TerminateSequenceResponseType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__TerminateSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__TerminateSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__TerminateSequenceResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__TerminateSequenceResponseType, sizeof(struct wsrm__TerminateSequenceResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__TerminateSequenceResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__TerminateSequenceResponseType, 0, sizeof(struct wsrm__TerminateSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__TerminateSequenceResponseType(struct soap *soap, const struct wsrm__TerminateSequenceResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__TerminateSequenceResponseType);
	if (soap_out_wsrm__TerminateSequenceResponseType(soap, tag?tag:"wsrm:TerminateSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__TerminateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__TerminateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__TerminateSequenceResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__TerminateSequenceResponseType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__TerminateSequenceResponseType);
		if (size)
			*size = sizeof(struct wsrm__TerminateSequenceResponseType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__TerminateSequenceResponseType, n);
		if (size)
			*size = n * sizeof(struct wsrm__TerminateSequenceResponseType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__TerminateSequenceResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__TerminateSequenceResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__TerminateSequenceResponseType %p -> %p\n", q, p));
	*(struct wsrm__TerminateSequenceResponseType*)p = *(struct wsrm__TerminateSequenceResponseType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__TerminateSequenceType(struct soap *soap, const struct wsrm__TerminateSequenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__TerminateSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__TerminateSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__TerminateSequenceType), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType * SOAP_FMAC4 soap_in_wsrm__TerminateSequenceType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__TerminateSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__TerminateSequenceType, sizeof(struct wsrm__TerminateSequenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__TerminateSequenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__TerminateSequenceType, 0, sizeof(struct wsrm__TerminateSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__TerminateSequenceType(struct soap *soap, const struct wsrm__TerminateSequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__TerminateSequenceType);
	if (soap_out_wsrm__TerminateSequenceType(soap, tag?tag:"wsrm:TerminateSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType * SOAP_FMAC4 soap_get_wsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__TerminateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__TerminateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__TerminateSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__TerminateSequenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__TerminateSequenceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__TerminateSequenceType);
		if (size)
			*size = sizeof(struct wsrm__TerminateSequenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__TerminateSequenceType, n);
		if (size)
			*size = n * sizeof(struct wsrm__TerminateSequenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__TerminateSequenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__TerminateSequenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__TerminateSequenceType %p -> %p\n", q, p));
	*(struct wsrm__TerminateSequenceType*)p = *(struct wsrm__TerminateSequenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CloseSequenceResponseType(struct soap *soap, const struct wsrm__CloseSequenceResponseType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__CloseSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CloseSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__CloseSequenceResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CloseSequenceResponseType, sizeof(struct wsrm__CloseSequenceResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CloseSequenceResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CloseSequenceResponseType, 0, sizeof(struct wsrm__CloseSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CloseSequenceResponseType(struct soap *soap, const struct wsrm__CloseSequenceResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__CloseSequenceResponseType);
	if (soap_out_wsrm__CloseSequenceResponseType(soap, tag?tag:"wsrm:CloseSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CloseSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__CloseSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CloseSequenceResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__CloseSequenceResponseType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__CloseSequenceResponseType);
		if (size)
			*size = sizeof(struct wsrm__CloseSequenceResponseType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__CloseSequenceResponseType, n);
		if (size)
			*size = n * sizeof(struct wsrm__CloseSequenceResponseType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__CloseSequenceResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__CloseSequenceResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__CloseSequenceResponseType %p -> %p\n", q, p));
	*(struct wsrm__CloseSequenceResponseType*)p = *(struct wsrm__CloseSequenceResponseType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CloseSequenceType(struct soap *soap, const struct wsrm__CloseSequenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CloseSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__CloseSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CloseSequenceType), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType * SOAP_FMAC4 soap_in_wsrm__CloseSequenceType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__CloseSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CloseSequenceType, sizeof(struct wsrm__CloseSequenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CloseSequenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CloseSequenceType, 0, sizeof(struct wsrm__CloseSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CloseSequenceType(struct soap *soap, const struct wsrm__CloseSequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__CloseSequenceType);
	if (soap_out_wsrm__CloseSequenceType(soap, tag?tag:"wsrm:CloseSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType * SOAP_FMAC4 soap_get_wsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CloseSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__CloseSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CloseSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CloseSequenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__CloseSequenceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__CloseSequenceType);
		if (size)
			*size = sizeof(struct wsrm__CloseSequenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__CloseSequenceType, n);
		if (size)
			*size = n * sizeof(struct wsrm__CloseSequenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__CloseSequenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__CloseSequenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__CloseSequenceType %p -> %p\n", q, p));
	*(struct wsrm__CloseSequenceType*)p = *(struct wsrm__CloseSequenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	a->Expires = NULL;
	a->IncompleteSequenceBehavior = NULL;
	a->Accept = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CreateSequenceResponseType(struct soap *soap, const struct wsrm__CreateSequenceResponseType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(soap, &a->IncompleteSequenceBehavior);
	soap_serialize_PointerTowsrm__AcceptType(soap, &a->Accept);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, int id, const struct wsrm__CreateSequenceResponseType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CreateSequenceResponseType), type))
		return soap->error;
	if (a->Identifier)
		soap_element_result(soap, "wsrm:Identifier");
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", -1, &a->IncompleteSequenceBehavior, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__AcceptType(soap, "wsrm:Accept", -1, &a->Accept, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType * SOAP_FMAC4 soap_in_wsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceResponseType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_IncompleteSequenceBehavior = 1;
	size_t soap_flag_Accept = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__CreateSequenceResponseType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CreateSequenceResponseType, sizeof(struct wsrm__CreateSequenceResponseType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CreateSequenceResponseType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap_flag_IncompleteSequenceBehavior && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, "wsrm:IncompleteSequenceBehavior", &a->IncompleteSequenceBehavior, "wsrm:IncompleteSequenceBehaviorType"))
				{	soap_flag_IncompleteSequenceBehavior--;
					continue;
				}
			if (soap_flag_Accept && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__AcceptType(soap, "wsrm:Accept", &a->Accept, "wsrm:AcceptType"))
				{	soap_flag_Accept--;
					continue;
				}
			soap_check_result(soap, "wsrm:Identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CreateSequenceResponseType, 0, sizeof(struct wsrm__CreateSequenceResponseType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CreateSequenceResponseType(struct soap *soap, const struct wsrm__CreateSequenceResponseType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__CreateSequenceResponseType);
	if (soap_out_wsrm__CreateSequenceResponseType(soap, tag?tag:"wsrm:CreateSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType * SOAP_FMAC4 soap_get_wsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CreateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__CreateSequenceResponseType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CreateSequenceResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__CreateSequenceResponseType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__CreateSequenceResponseType);
		if (size)
			*size = sizeof(struct wsrm__CreateSequenceResponseType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__CreateSequenceResponseType, n);
		if (size)
			*size = n * sizeof(struct wsrm__CreateSequenceResponseType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__CreateSequenceResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__CreateSequenceResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__CreateSequenceResponseType %p -> %p\n", q, p));
	*(struct wsrm__CreateSequenceResponseType*)p = *(struct wsrm__CreateSequenceResponseType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->AcksTo);
	a->Expires = NULL;
	a->Offer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__CreateSequenceType(struct soap *soap, const struct wsrm__CreateSequenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->AcksTo);
	soap_serialize_PointerToxsd__duration(soap, &a->Expires);
	soap_serialize_PointerTowsrm__OfferType(soap, &a->Offer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__CreateSequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__CreateSequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__CreateSequenceType), type))
		return soap->error;
	if (soap_out_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", -1, &a->AcksTo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "wsrm:Expires", -1, &a->Expires, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__OfferType(soap, "wsrm:Offer", -1, &a->Offer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType * SOAP_FMAC4 soap_in_wsrm__CreateSequenceType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceType *a, const char *type)
{
	size_t soap_flag_AcksTo = 1;
	size_t soap_flag_Expires = 1;
	size_t soap_flag_Offer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__CreateSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__CreateSequenceType, sizeof(struct wsrm__CreateSequenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__CreateSequenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcksTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "wsrm:AcksTo", &a->AcksTo, "wsa5:EndpointReferenceType"))
				{	soap_flag_AcksTo--;
					continue;
				}
			if (soap_flag_Expires && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "wsrm:Expires", &a->Expires, "xsd:duration"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap_flag_Offer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__OfferType(soap, "wsrm:Offer", &a->Offer, "wsrm:OfferType"))
				{	soap_flag_Offer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__CreateSequenceType, 0, sizeof(struct wsrm__CreateSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AcksTo > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__CreateSequenceType(struct soap *soap, const struct wsrm__CreateSequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__CreateSequenceType);
	if (soap_out_wsrm__CreateSequenceType(soap, tag?tag:"wsrm:CreateSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType * SOAP_FMAC4 soap_get_wsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__CreateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__CreateSequenceType * SOAP_FMAC2 soap_instantiate_wsrm__CreateSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__CreateSequenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__CreateSequenceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__CreateSequenceType);
		if (size)
			*size = sizeof(struct wsrm__CreateSequenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__CreateSequenceType, n);
		if (size)
			*size = n * sizeof(struct wsrm__CreateSequenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__CreateSequenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__CreateSequenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__CreateSequenceType %p -> %p\n", q, p));
	*(struct wsrm__CreateSequenceType*)p = *(struct wsrm__CreateSequenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsrm__FaultCodes(soap, &a->FaultCode);
	a->Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__SequenceFaultType(struct soap *soap, const struct wsrm__SequenceFaultType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__SequenceFaultType(struct soap *soap, const char *tag, int id, const struct wsrm__SequenceFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__SequenceFaultType), type))
		return soap->error;
	if (soap_out_wsrm__FaultCodes(soap, "wsrm:FaultCode", -1, &a->FaultCode, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "wsrm:Detail", -1, &a->Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType * SOAP_FMAC4 soap_in_wsrm__SequenceFaultType(struct soap *soap, const char *tag, struct wsrm__SequenceFaultType *a, const char *type)
{
	size_t soap_flag_FaultCode = 1;
	size_t soap_flag_Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__SequenceFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__SequenceFaultType, sizeof(struct wsrm__SequenceFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__SequenceFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FaultCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsrm__FaultCodes(soap, "wsrm:FaultCode", &a->FaultCode, "wsrm:FaultCodes"))
				{	soap_flag_FaultCode--;
					continue;
				}
			if (soap_flag_Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "wsrm:Detail", &a->Detail, ""))
				{	soap_flag_Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__SequenceFaultType, 0, sizeof(struct wsrm__SequenceFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FaultCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__SequenceFaultType(struct soap *soap, const struct wsrm__SequenceFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__SequenceFaultType);
	if (soap_out_wsrm__SequenceFaultType(soap, tag?tag:"wsrm:SequenceFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType * SOAP_FMAC4 soap_get_wsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__SequenceFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__SequenceFaultType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__SequenceFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__SequenceFaultType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__SequenceFaultType);
		if (size)
			*size = sizeof(struct wsrm__SequenceFaultType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__SequenceFaultType, n);
		if (size)
			*size = n * sizeof(struct wsrm__SequenceFaultType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__SequenceFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__SequenceFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__SequenceFaultType %p -> %p\n", q, p));
	*(struct wsrm__SequenceFaultType*)p = *(struct wsrm__SequenceFaultType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__AckRequestedType(struct soap *soap, const struct wsrm__AckRequestedType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__AckRequestedType(struct soap *soap, const char *tag, int id, const struct wsrm__AckRequestedType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__AckRequestedType), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__AckRequestedType * SOAP_FMAC4 soap_in_wsrm__AckRequestedType(struct soap *soap, const char *tag, struct wsrm__AckRequestedType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__AckRequestedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__AckRequestedType, sizeof(struct wsrm__AckRequestedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__AckRequestedType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__AckRequestedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__AckRequestedType, 0, sizeof(struct wsrm__AckRequestedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__AckRequestedType(struct soap *soap, const struct wsrm__AckRequestedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__AckRequestedType);
	if (soap_out_wsrm__AckRequestedType(soap, tag?tag:"wsrm:AckRequestedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AckRequestedType * SOAP_FMAC4 soap_get_wsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__AckRequestedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__AckRequestedType * SOAP_FMAC2 soap_instantiate_wsrm__AckRequestedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__AckRequestedType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__AckRequestedType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__AckRequestedType);
		if (size)
			*size = sizeof(struct wsrm__AckRequestedType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__AckRequestedType, n);
		if (size)
			*size = n * sizeof(struct wsrm__AckRequestedType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__AckRequestedType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__AckRequestedType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__AckRequestedType %p -> %p\n", q, p));
	*(struct wsrm__AckRequestedType*)p = *(struct wsrm__AckRequestedType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Identifier);
	soap_default_unsignedLONG64(soap, &a->MessageNumber);
	a->LastMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrm__SequenceType(struct soap *soap, const struct wsrm__SequenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	soap_embedded(soap, &a->MessageNumber, SOAP_TYPE_unsignedLONG64);
	soap_serialize_PointerTo_wsrm__UsesSequenceSSL(soap, &a->LastMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrm__SequenceType(struct soap *soap, const char *tag, int id, const struct wsrm__SequenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrm__SequenceType), type))
		return soap->error;
	if (a->Identifier)
	{	if (soap_out_string(soap, "wsrm:Identifier", -1, &a->Identifier, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsrm:Identifier"))
		return soap->error;
	if (soap_out_unsignedLONG64(soap, "wsrm:MessageNumber", -1, &a->MessageNumber, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, "wsrm:LastMessage", -1, &a->LastMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrm__SequenceType * SOAP_FMAC4 soap_in_wsrm__SequenceType(struct soap *soap, const char *tag, struct wsrm__SequenceType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_MessageNumber = 1;
	size_t soap_flag_LastMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrm__SequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrm__SequenceType, sizeof(struct wsrm__SequenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrm__SequenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsrm:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_MessageNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedLONG64(soap, "wsrm:MessageNumber", &a->MessageNumber, "xsd:unsignedLong"))
				{	soap_flag_MessageNumber--;
					continue;
				}
			if (soap_flag_LastMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, "wsrm:LastMessage", &a->LastMessage, ""))
				{	soap_flag_LastMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrm__SequenceType, 0, sizeof(struct wsrm__SequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier > 0 || soap_flag_MessageNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrm__SequenceType(struct soap *soap, const struct wsrm__SequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsrm__SequenceType);
	if (soap_out_wsrm__SequenceType(soap, tag?tag:"wsrm:SequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceType * SOAP_FMAC4 soap_get_wsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrm__SequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsrm__SequenceType * SOAP_FMAC2 soap_instantiate_wsrm__SequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsrm__SequenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsrm__SequenceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsrm__SequenceType);
		if (size)
			*size = sizeof(struct wsrm__SequenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsrm__SequenceType, n);
		if (size)
			*size = n * sizeof(struct wsrm__SequenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsrm__SequenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsrm__SequenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsrm__SequenceType %p -> %p\n", q, p));
	*(struct wsrm__SequenceType*)p = *(struct wsrm__SequenceType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
	a->wsrm__Sequence = NULL;
	a->__sizeAckRequested = 0;
	a->wsrm__AckRequested = NULL;
	a->__sizeSequenceAcknowledgement = 0;
	a->wsrm__SequenceAcknowledgement = NULL;
	a->wsrm__SequenceFault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
	soap_serialize_PointerTowsrm__SequenceType(soap, &a->wsrm__Sequence);
	if (a->wsrm__AckRequested)
	{	int i;
		for (i = 0; i < a->__sizeAckRequested; i++)
		{
			soap_embedded(soap, a->wsrm__AckRequested + i, SOAP_TYPE_wsrm__AckRequestedType);
			soap_serialize_wsrm__AckRequestedType(soap, a->wsrm__AckRequested + i);
		}
	}
	if (a->wsrm__SequenceAcknowledgement)
	{	int i;
		for (i = 0; i < a->__sizeSequenceAcknowledgement; i++)
		{
			soap_embedded(soap, a->wsrm__SequenceAcknowledgement + i, SOAP_TYPE__wsrm__SequenceAcknowledgement);
			soap_serialize__wsrm__SequenceAcknowledgement(soap, a->wsrm__SequenceAcknowledgement + i);
		}
	}
	soap_serialize_PointerTowsrm__SequenceFaultType(soap, &a->wsrm__SequenceFault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (soap_out_PointerTowsrm__SequenceType(soap, "wsrm:Sequence", -1, &a->wsrm__Sequence, ""))
		return soap->error;
	if (a->wsrm__AckRequested)
	{	int i;
		for (i = 0; i < a->__sizeAckRequested; i++)
			if (soap_out_wsrm__AckRequestedType(soap, "wsrm:AckRequested", -1, a->wsrm__AckRequested + i, ""))
				return soap->error;
	}
	if (a->wsrm__SequenceAcknowledgement)
	{	int i;
		for (i = 0; i < a->__sizeSequenceAcknowledgement; i++)
			if (soap_out__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", -1, a->wsrm__SequenceAcknowledgement + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTowsrm__SequenceFaultType(soap, "wsrm:SequenceFault", -1, &a->wsrm__SequenceFault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	size_t soap_flag_wsrm__Sequence = 1;
	struct soap_blist *soap_blist_wsrm__AckRequested = NULL;
	struct soap_blist *soap_blist_wsrm__SequenceAcknowledgement = NULL;
	size_t soap_flag_wsrm__SequenceFault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap_flag_wsrm__Sequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__SequenceType(soap, "wsrm:Sequence", &a->wsrm__Sequence, "wsrm:SequenceType"))
				{	soap_flag_wsrm__Sequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:AckRequested", 1, NULL))
			{	if (a->wsrm__AckRequested == NULL)
				{	if (soap_blist_wsrm__AckRequested == NULL)
						soap_blist_wsrm__AckRequested = soap_new_block(soap);
					a->wsrm__AckRequested = (struct wsrm__AckRequestedType *)soap_push_block(soap, soap_blist_wsrm__AckRequested, sizeof(struct wsrm__AckRequestedType));
					if (a->wsrm__AckRequested == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->wsrm__AckRequested, struct wsrm__AckRequestedType);
					soap_default_wsrm__AckRequestedType(soap, a->wsrm__AckRequested);
				}
				soap_revert(soap);
				if (soap_in_wsrm__AckRequestedType(soap, "wsrm:AckRequested", a->wsrm__AckRequested, "wsrm:AckRequestedType"))
				{	a->__sizeAckRequested++;
					a->wsrm__AckRequested = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrm:SequenceAcknowledgement", 1, NULL))
			{	if (a->wsrm__SequenceAcknowledgement == NULL)
				{	if (soap_blist_wsrm__SequenceAcknowledgement == NULL)
						soap_blist_wsrm__SequenceAcknowledgement = soap_new_block(soap);
					a->wsrm__SequenceAcknowledgement = (struct _wsrm__SequenceAcknowledgement *)soap_push_block(soap, soap_blist_wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement));
					if (a->wsrm__SequenceAcknowledgement == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->wsrm__SequenceAcknowledgement, struct _wsrm__SequenceAcknowledgement);
					soap_default__wsrm__SequenceAcknowledgement(soap, a->wsrm__SequenceAcknowledgement);
				}
				soap_revert(soap);
				if (soap_in__wsrm__SequenceAcknowledgement(soap, "wsrm:SequenceAcknowledgement", a->wsrm__SequenceAcknowledgement, ""))
				{	a->__sizeSequenceAcknowledgement++;
					a->wsrm__SequenceAcknowledgement = NULL;
					continue;
				}
			}
			if (soap_flag_wsrm__SequenceFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrm__SequenceFaultType(soap, "wsrm:SequenceFault", &a->wsrm__SequenceFault, "wsrm:SequenceFaultType"))
				{	soap_flag_wsrm__SequenceFault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrm__AckRequested)
			soap_pop_block(soap, soap_blist_wsrm__AckRequested);
		if (a->__sizeAckRequested)
			a->wsrm__AckRequested = (struct wsrm__AckRequestedType *)soap_save_block(soap, soap_blist_wsrm__AckRequested, NULL, 1);
		else
		{	a->wsrm__AckRequested = NULL;
			if (soap_blist_wsrm__AckRequested)
				soap_end_block(soap, soap_blist_wsrm__AckRequested);
		}
		if (a->wsrm__SequenceAcknowledgement)
			soap_pop_block(soap, soap_blist_wsrm__SequenceAcknowledgement);
		if (a->__sizeSequenceAcknowledgement)
			a->wsrm__SequenceAcknowledgement = (struct _wsrm__SequenceAcknowledgement *)soap_save_block(soap, soap_blist_wsrm__SequenceAcknowledgement, NULL, 1);
		else
		{	a->wsrm__SequenceAcknowledgement = NULL;
			if (soap_blist_wsrm__SequenceAcknowledgement)
				soap_end_block(soap, soap_blist_wsrm__SequenceAcknowledgement);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct chan__ChannelInstanceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_chan__ChannelInstanceType);
	if (soap_out_chan__ChannelInstanceType(soap, tag?tag:"chan:ChannelInstanceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_chan__ChannelInstanceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct chan__ChannelInstanceType);
		if (size)
			*size = sizeof(struct chan__ChannelInstanceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct chan__ChannelInstanceType, n);
		if (size)
			*size = n * sizeof(struct chan__ChannelInstanceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct chan__ChannelInstanceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_chan__ChannelInstanceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct chan__ChannelInstanceType %p -> %p\n", q, p));
	*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ProblemActionType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType);
		if (size)
			*size = sizeof(struct wsa5__ProblemActionType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__ProblemActionType, n);
		if (size)
			*size = n * sizeof(struct wsa5__ProblemActionType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__ProblemActionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ProblemActionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ProblemActionType %p -> %p\n", q, p));
	*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__RelatesToType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType);
		if (size)
			*size = sizeof(struct wsa5__RelatesToType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__RelatesToType, n);
		if (size)
			*size = n * sizeof(struct wsa5__RelatesToType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__RelatesToType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__RelatesToType %p -> %p\n", q, p));
	*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__MetadataType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType);
		if (size)
			*size = sizeof(struct wsa5__MetadataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__MetadataType, n);
		if (size)
			*size = n * sizeof(struct wsa5__MetadataType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__MetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__MetadataType %p -> %p\n", q, p));
	*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ReferenceParametersType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType);
		if (size)
			*size = sizeof(struct wsa5__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__ReferenceParametersType, n);
		if (size)
			*size = n * sizeof(struct wsa5__ReferenceParametersType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__ReferenceParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__EndpointReferenceType, n, wsrx_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType);
		if (size)
			*size = sizeof(struct wsa5__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__EndpointReferenceType, n);
		if (size)
			*size = n * sizeof(struct wsa5__EndpointReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__EndpointReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__TerminateSequenceResponseType))
		soap_serialize_wsrm__TerminateSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__TerminateSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__TerminateSequenceResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__TerminateSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__TerminateSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__TerminateSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__TerminateSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__TerminateSequenceResponseType, sizeof(struct wsrm__TerminateSequenceResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__TerminateSequenceResponseType);
	if (soap_out_PointerTowsrm__TerminateSequenceResponseType(soap, tag?tag:"wsrm:TerminateSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__TerminateSequenceResponseType(struct soap *soap, struct wsrm__TerminateSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__TerminateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__TerminateSequenceType))
		soap_serialize_wsrm__TerminateSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__TerminateSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__TerminateSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__TerminateSequenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__TerminateSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__TerminateSequenceType(struct soap *soap, const char *tag, struct wsrm__TerminateSequenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__TerminateSequenceType **)soap_malloc(soap, sizeof(struct wsrm__TerminateSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__TerminateSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__TerminateSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__TerminateSequenceType, sizeof(struct wsrm__TerminateSequenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__TerminateSequenceType);
	if (soap_out_PointerTowsrm__TerminateSequenceType(soap, tag?tag:"wsrm:TerminateSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__TerminateSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__TerminateSequenceType(struct soap *soap, struct wsrm__TerminateSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__TerminateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CloseSequenceResponseType))
		soap_serialize_wsrm__CloseSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__CloseSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CloseSequenceResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CloseSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CloseSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__CloseSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CloseSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CloseSequenceResponseType, sizeof(struct wsrm__CloseSequenceResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__CloseSequenceResponseType);
	if (soap_out_PointerTowsrm__CloseSequenceResponseType(soap, tag?tag:"wsrm:CloseSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__CloseSequenceResponseType(struct soap *soap, struct wsrm__CloseSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CloseSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CloseSequenceType))
		soap_serialize_wsrm__CloseSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CloseSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__CloseSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CloseSequenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CloseSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__CloseSequenceType(struct soap *soap, const char *tag, struct wsrm__CloseSequenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CloseSequenceType **)soap_malloc(soap, sizeof(struct wsrm__CloseSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CloseSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CloseSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CloseSequenceType, sizeof(struct wsrm__CloseSequenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__CloseSequenceType);
	if (soap_out_PointerTowsrm__CloseSequenceType(soap, tag?tag:"wsrm:CloseSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CloseSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__CloseSequenceType(struct soap *soap, struct wsrm__CloseSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CloseSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CreateSequenceResponseType))
		soap_serialize_wsrm__CreateSequenceResponseType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, int id, struct wsrm__CreateSequenceResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CreateSequenceResponseType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CreateSequenceResponseType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType ** SOAP_FMAC4 soap_in_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CreateSequenceResponseType **)soap_malloc(soap, sizeof(struct wsrm__CreateSequenceResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CreateSequenceResponseType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CreateSequenceResponseType, sizeof(struct wsrm__CreateSequenceResponseType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__CreateSequenceResponseType);
	if (soap_out_PointerTowsrm__CreateSequenceResponseType(soap, tag?tag:"wsrm:CreateSequenceResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceResponseType ** SOAP_FMAC4 soap_get_PointerTowsrm__CreateSequenceResponseType(struct soap *soap, struct wsrm__CreateSequenceResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CreateSequenceResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__CreateSequenceType))
		soap_serialize_wsrm__CreateSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__CreateSequenceType(struct soap *soap, const char *tag, int id, struct wsrm__CreateSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__CreateSequenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__CreateSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__CreateSequenceType(struct soap *soap, const char *tag, struct wsrm__CreateSequenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__CreateSequenceType **)soap_malloc(soap, sizeof(struct wsrm__CreateSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__CreateSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__CreateSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__CreateSequenceType, sizeof(struct wsrm__CreateSequenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__CreateSequenceType);
	if (soap_out_PointerTowsrm__CreateSequenceType(soap, tag?tag:"wsrm:CreateSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__CreateSequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__CreateSequenceType(struct soap *soap, struct wsrm__CreateSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__CreateSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__SequenceFaultType))
		soap_serialize_wsrm__SequenceFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__SequenceFaultType(struct soap *soap, const char *tag, int id, struct wsrm__SequenceFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__SequenceFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__SequenceFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType ** SOAP_FMAC4 soap_in_PointerTowsrm__SequenceFaultType(struct soap *soap, const char *tag, struct wsrm__SequenceFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__SequenceFaultType **)soap_malloc(soap, sizeof(struct wsrm__SequenceFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__SequenceFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__SequenceFaultType, sizeof(struct wsrm__SequenceFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__SequenceFaultType);
	if (soap_out_PointerTowsrm__SequenceFaultType(soap, tag?tag:"wsrm:SequenceFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceFaultType ** SOAP_FMAC4 soap_get_PointerTowsrm__SequenceFaultType(struct soap *soap, struct wsrm__SequenceFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__SequenceFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement))
		soap_serialize__wsrm__SequenceAcknowledgement(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement, sizeof(struct _wsrm__SequenceAcknowledgement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement);
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement(soap, tag?tag:"wsrm:SequenceAcknowledgement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement(struct soap *soap, struct _wsrm__SequenceAcknowledgement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__AckRequestedType))
		soap_serialize_wsrm__AckRequestedType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__AckRequestedType(struct soap *soap, const char *tag, int id, struct wsrm__AckRequestedType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__AckRequestedType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__AckRequestedType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__AckRequestedType ** SOAP_FMAC4 soap_in_PointerTowsrm__AckRequestedType(struct soap *soap, const char *tag, struct wsrm__AckRequestedType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__AckRequestedType **)soap_malloc(soap, sizeof(struct wsrm__AckRequestedType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__AckRequestedType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__AckRequestedType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__AckRequestedType, sizeof(struct wsrm__AckRequestedType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__AckRequestedType);
	if (soap_out_PointerTowsrm__AckRequestedType(soap, tag?tag:"wsrm:AckRequestedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AckRequestedType ** SOAP_FMAC4 soap_get_PointerTowsrm__AckRequestedType(struct soap *soap, struct wsrm__AckRequestedType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__AckRequestedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__SequenceType))
		soap_serialize_wsrm__SequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__SequenceType(struct soap *soap, const char *tag, int id, struct wsrm__SequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__SequenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__SequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__SequenceType ** SOAP_FMAC4 soap_in_PointerTowsrm__SequenceType(struct soap *soap, const char *tag, struct wsrm__SequenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__SequenceType **)soap_malloc(soap, sizeof(struct wsrm__SequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__SequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__SequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__SequenceType, sizeof(struct wsrm__SequenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__SequenceType);
	if (soap_out_PointerTowsrm__SequenceType(soap, tag?tag:"wsrm:SequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__SequenceType ** SOAP_FMAC4 soap_get_PointerTowsrm__SequenceType(struct soap *soap, struct wsrm__SequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__SequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None))
		soap_serialize__wsrm__SequenceAcknowledgement_None(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_None *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_None);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_None(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_None **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_None **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_None *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_None(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_None **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_None, sizeof(struct _wsrm__SequenceAcknowledgement_None), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_None);
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag?tag:"wsrm:SequenceAcknowledgement-None", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_None ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_None(struct soap *soap, struct _wsrm__SequenceAcknowledgement_None **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_None(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange))
		soap_serialize__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_AcknowledgementRange, sizeof(struct _wsrm__SequenceAcknowledgement_AcknowledgementRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange);
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag?tag:"wsrm:SequenceAcknowledgement-AcknowledgementRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_AcknowledgementRange ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(struct soap *soap, struct _wsrm__SequenceAcknowledgement_AcknowledgementRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_AcknowledgementRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final))
		soap_serialize__wsrm__SequenceAcknowledgement_Final(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, int id, struct _wsrm__SequenceAcknowledgement_Final *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__SequenceAcknowledgement_Final(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final ** SOAP_FMAC4 soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, const char *tag, struct _wsrm__SequenceAcknowledgement_Final **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__SequenceAcknowledgement_Final **)soap_malloc(soap, sizeof(struct _wsrm__SequenceAcknowledgement_Final *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__SequenceAcknowledgement_Final(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__SequenceAcknowledgement_Final **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__SequenceAcknowledgement_Final, sizeof(struct _wsrm__SequenceAcknowledgement_Final), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrm__SequenceAcknowledgement_Final);
	if (soap_out_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag?tag:"wsrm:SequenceAcknowledgement-Final", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__SequenceAcknowledgement_Final ** SOAP_FMAC4 soap_get_PointerTo_wsrm__SequenceAcknowledgement_Final(struct soap *soap, struct _wsrm__SequenceAcknowledgement_Final **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__SequenceAcknowledgement_Final(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__AcceptType))
		soap_serialize_wsrm__AcceptType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__AcceptType(struct soap *soap, const char *tag, int id, struct wsrm__AcceptType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__AcceptType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__AcceptType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__AcceptType ** SOAP_FMAC4 soap_in_PointerTowsrm__AcceptType(struct soap *soap, const char *tag, struct wsrm__AcceptType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__AcceptType **)soap_malloc(soap, sizeof(struct wsrm__AcceptType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__AcceptType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__AcceptType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__AcceptType, sizeof(struct wsrm__AcceptType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__AcceptType);
	if (soap_out_PointerTowsrm__AcceptType(soap, tag?tag:"wsrm:AcceptType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__AcceptType ** SOAP_FMAC4 soap_get_PointerTowsrm__AcceptType(struct soap *soap, struct wsrm__AcceptType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__AcceptType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, int id, enum wsrm__IncompleteSequenceBehaviorType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__IncompleteSequenceBehaviorType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType ** SOAP_FMAC4 soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, const char *tag, enum wsrm__IncompleteSequenceBehaviorType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum wsrm__IncompleteSequenceBehaviorType **)soap_malloc(soap, sizeof(enum wsrm__IncompleteSequenceBehaviorType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__IncompleteSequenceBehaviorType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum wsrm__IncompleteSequenceBehaviorType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__IncompleteSequenceBehaviorType, sizeof(enum wsrm__IncompleteSequenceBehaviorType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__IncompleteSequenceBehaviorType);
	if (soap_out_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag?tag:"wsrm:IncompleteSequenceBehaviorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsrm__IncompleteSequenceBehaviorType ** SOAP_FMAC4 soap_get_PointerTowsrm__IncompleteSequenceBehaviorType(struct soap *soap, enum wsrm__IncompleteSequenceBehaviorType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__IncompleteSequenceBehaviorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrm__OfferType))
		soap_serialize_wsrm__OfferType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrm__OfferType(struct soap *soap, const char *tag, int id, struct wsrm__OfferType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrm__OfferType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrm__OfferType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrm__OfferType ** SOAP_FMAC4 soap_in_PointerTowsrm__OfferType(struct soap *soap, const char *tag, struct wsrm__OfferType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrm__OfferType **)soap_malloc(soap, sizeof(struct wsrm__OfferType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrm__OfferType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrm__OfferType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrm__OfferType, sizeof(struct wsrm__OfferType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrm__OfferType);
	if (soap_out_PointerTowsrm__OfferType(soap, tag?tag:"wsrm:OfferType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrm__OfferType ** SOAP_FMAC4 soap_get_PointerTowsrm__OfferType(struct soap *soap, struct wsrm__OfferType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrm__OfferType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrm__UsesSequenceSSL))
		soap_serialize__wsrm__UsesSequenceSSL(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, int id, struct _wsrm__UsesSequenceSSL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrm__UsesSequenceSSL);
	if (id < 0)
		return soap->error;
	return soap_out__wsrm__UsesSequenceSSL(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL ** SOAP_FMAC4 soap_in_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, const char *tag, struct _wsrm__UsesSequenceSSL **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrm__UsesSequenceSSL **)soap_malloc(soap, sizeof(struct _wsrm__UsesSequenceSSL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrm__UsesSequenceSSL(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrm__UsesSequenceSSL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrm__UsesSequenceSSL, sizeof(struct _wsrm__UsesSequenceSSL), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrm__UsesSequenceSSL);
	if (soap_out_PointerTo_wsrm__UsesSequenceSSL(soap, tag?tag:"wsrm:UsesSequenceSSL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrm__UsesSequenceSSL ** SOAP_FMAC4 soap_get_PointerTo_wsrm__UsesSequenceSSL(struct soap *soap, struct _wsrm__UsesSequenceSSL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrm__UsesSequenceSSL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTochan__ChannelInstanceType);
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag?tag:"chan:ChannelInstanceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__wsa5__ProblemHeaderQName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
	if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of wsrxC.cpp */
