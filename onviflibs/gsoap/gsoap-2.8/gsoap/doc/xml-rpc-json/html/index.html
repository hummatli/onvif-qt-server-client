<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>gSOAP XML-RPC and JSON: XML-RPC and JSON</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP XML-RPC and JSON
   &#160;<span id="projectnumber">2.8 Stable</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">XML-RPC and JSON </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cpp">C++ XML-RPC and JSON                                                      </a><ul><li class="level2"><a href="#cpp-ex">C++ Examples                                                           </a></li>
<li class="level2"><a href="#cpp-cl">C++ XML-RPC Client Example                                             </a></li>
<li class="level2"><a href="#cpp-sr">C++ XML-RPC Server Example                                             </a></li>
<li class="level2"><a href="#cpp-io">C++ XML-RPC Data Serialization from/to Streams                         </a></li>
<li class="level2"><a href="#cpp-js">C++ JSON Serialization from/to Streams                                 </a></li>
<li class="level2"><a href="#cpp-jr">C++ JSON-RPC over HTTP (REST method)                                   </a></li>
</ul>
</li>
<li class="level1"><a href="#c">C XML-RPC and JSON                                                          </a><ul><li class="level2"><a href="#c-ex">C Examples                                                               </a></li>
<li class="level2"><a href="#c-cl">C XML-RPC Client Example                                                 </a></li>
<li class="level2"><a href="#c-js">C JSON Serialization                                                     </a></li>
<li class="level2"><a href="#c-jr">C JSON-RPC over HTTP (REST method)                                       </a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>XML-RPC is a simple and effective messaging protocol. XML-RPC uses a generic XML format to compose XML messages for platform-neutral data exchange. XML-RPC serialization proceeds by marshaling parameters in predefined XML elements. A simple type system is provided to cover primitive types, structs, and arrays. That is, XML-RPC defines a collection of frequently used XML types with common programming language equivalents. XML-RPC does NOT provide a data binding to XML and does NOT support a validation mechanism to ensure that data content is validated against a data type or schema.</p>
<p>See <a href="http://www.xmlrpc.com">http://www.xmlrpc.com</a> for more details.</p>
<p>JSON (JavaScript Object Notation) is an even simpler data format to support platform-neutral data interchange that is highly compatible across programming languages.</p>
<p>See <a href="http://www.json.org">http://www.json.org</a> for more details.</p>
<h1><a class="anchor" id="cpp"></a>
C++ XML-RPC and JSON                                                      </h1>
<p>XML-RPC and JSON data is largely interchangeable in this implementation. That is, XML-RPC data can be converted to/from JSON data by simply choosing the XML-RPC or the JSON serializer. Data is interchangeable with the exception of XML-RPC dateTime and XML-RPC base64-encoded data that have no JSON equivalents. Also, JSON only supports floats. Ints are converted to double floats by the JSON serializer. Developers should be aware of these limitations as a JSON receiver will never receive an int value, dateTime, and base64 raw data. This implementation sends ints as floats and dateTime and base64 data as string type content in JSON.</p>
<p>The following source files are provided for XML-RPC support in C++:</p>
<ul>
<li><code>xml-rpc.cpp</code>: C++ XML-RPC implementation and data management</li>
<li><code>xml-rpc-io.h</code>: C++ XML-RPC data serialization over streams</li>
<li><code>xml-rpc-io.cpp</code>: C++ XML-RPC data serialization over streams</li>
<li><code><a class="el" href="xml-rpc-iters_8h.html">xml-rpc-iters.h</a></code>: C++ iterators for structs, arrays, and parameters</li>
<li><code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code>: XML-RPC binding as a gSOAP .h file for soapcpp2 (do not #include this file in your project builds)</li>
</ul>
<p>For JSON serialization in C++, use the following files:</p>
<ul>
<li><code><a class="el" href="json_8h.html">json.h</a></code>: C++ JSON serializer over streams</li>
<li><code>json.cpp</code>: C++ JSON serializer over streams</li>
</ul>
<p>For JSON-RPC over HTTP (JSON REST method), please use the <code>plugin/httppost.c</code> plugin. See <a href="#cpp-jr">JSON-RPC over HTTP</a> explanation below.</p>
<p>Auto-generated files: note that <code>soapH.h</code>, <code>soapStub.h</code> and <code>soapC.cpp</code> are required for XML-RPC and JSON. To auto-generate these C++ files, execute: </p>
<pre class="fragment">soapcpp2 -CSL xml-rpc.h
</pre><p>Then compile and link these files together with <code>stdsoap2.cpp</code> (or link with <code>libgsoap++.a</code> installed by the gSOAP package).</p>
<h2><a class="anchor" id="cpp-ex"></a>
C++ Examples                                                           </h2>
<p>Examples are provided in the software package:</p>
<ul>
<li><code>xml-rpc-currentTime.cpp</code>: XML-RPC client in C++, also uses JSON</li>
<li><code>xml-rpc-currentTimeServer.cpp</code>: XML-RPC server in C++</li>
<li><code>xml-rpc-weblogs.cpp</code>: XML-RPC client in C++</li>
<li><code>xml-rpc-json.cpp</code>: XML-RPC to/from JSON example</li>
<li><code>json-currentTime.cpp</code>: JSON client in C++</li>
<li><code>json-currentTimeServer.cpp</code>: JSON server in C++</li>
</ul>
<p>See <code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code> for the C++ member functions to create XML-RPC messages and decode responses. These functions provide intuitive type casts, assignments, and indexing operations.</p>
<p>An XML-RPC data value is created in C++ as follows, which requires a context <code>ctx</code> for the engine state (the soap struct) for communication, and managed data allocation/deallocation:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
</div><!-- fragment --><p>Unicode can be stored in UTF8-formattted strings. For compatibility with XML-RPC serialization of UTF8-encoded strings, use the <code>SOAP_C_UTFSTRING</code> flag.</p>
<p>The code shown above creates an empty value <code>v</code>. It can be set by any one of the following assignments:</p>
<div class="fragment"><div class="line">v = 12345;                  <span class="comment">// an int</span></div>
<div class="line">v = 12.34;                  <span class="comment">// a double float</span></div>
<div class="line">v = <span class="stringliteral">&quot;abc&quot;</span>;                  <span class="comment">// a string</span></div>
<div class="line">v = string(<span class="stringliteral">&quot;abc&quot;</span>);          <span class="comment">// a std::string</span></div>
<div class="line">v = L<span class="stringliteral">&quot;xyz&quot;</span>;                 <span class="comment">// a wide string (converted to UTF8)</span></div>
<div class="line">v = wstring(L<span class="stringliteral">&quot;xyz&quot;</span>);        <span class="comment">// a std::wstring (converted to UTF8)</span></div>
<div class="line">v = <span class="keyword">false</span>;                  <span class="comment">// a Boolean</span></div>
<div class="line">v = time(0);                <span class="comment">// a time_t value serialized as XML-RPC dateTime</span></div>
<div class="line">v[0] = 24;                  <span class="comment">// an array of [24, 99.99, &quot;abc&quot;]</span></div>
<div class="line">v[1] = 99.99;</div>
<div class="line">v[2] = <span class="stringliteral">&quot;abc&quot;</span>;</div>
<div class="line">v[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;john&quot;</span>;         <span class="comment">// a struct {&quot;name&quot;: &quot;john&quot;, &quot;age&quot;: 24}</span></div>
<div class="line">v[<span class="stringliteral">&quot;age&quot;</span>] = 24;</div>
<div class="line"><a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a> img(ctx, 100, ptr_to_rawimage100bytes);</div>
<div class="line">v = img;                    <span class="comment">// a data block of 100 bytes in base64</span></div>
</div><!-- fragment --><p>You can combine this syntax to create arrays of arrays, arrays of structs, and so on, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
<div class="line">v[0][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;bob&quot;</span>;</div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>][0] = <span class="stringliteral">&quot;ball&quot;</span>;</div>
<div class="line">v[0][<span class="stringliteral">&quot;toys&quot;</span>][1] = <span class="stringliteral">&quot;furby&quot;</span>;</div>
</div><!-- fragment --><p>which creates a singleton array containing a struct with two members: <code>name</code> set to <code>"bob"</code> and <code>toys</code> set to an array containing <code>"ball"</code> and <code>"furby"</code>. In JSON format this is represented as: </p>
<pre class="fragment">           [ { "name": "bob", "toys": ["ball", "furby"] } ]
           ^ ^ ^              ^
           | | |              |
  an array_/ | |              |
 of 1 struct_/ |              |
with 2 members_/______________/
</pre><p>To check the type of a value, use the <code>is_type</code> methods:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#ae437ba0822eeec4bc1860040036ce8d1" title="true if value is int type">value::is_int</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a689089dd0cb6ac9649dbe33dd31e8199" title="true if value is double type">value::is_double</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a9b7b0789dc59f7a50c009c487777c282" title="true if value is string type">value::is_string</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a2afd8b5e664abc2ade103843c319ac0a" title="true if value is boolean type">value::is_bool</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a069d409dd697b189efdde36b5c61d195" title="true if value is boolean true">value::is_true</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a9b5ddfed406b282aec258787a72bb590" title="true if value is boolean false">value::is_false</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a4d040ec372e86bee35041501dbfbb233" title="true if value is dateTime">value::is_dateTime</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#acd5f0cc9c8de4b5a245223e227ee6b7e" title="true if value is array type">value::is_array</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a3fbb0450e00e7c69726479ea7ca30371" title="true if value is struct type">value::is_struct</a>();</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a1ee990d7bdf48e528f61bc1a133df651" title="true if value is base64 type">value::is_base64</a>();</div>
</div><!-- fragment --><p>There are three additional methods to invoke on a value:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="structvalue.html#a2db9152a4f86289696a72bd13e26e7b9" title="get array/struct size">value::size</a>(<span class="keywordtype">int</span>);      <span class="comment">// (re)set array size or pre-allocate space</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="structvalue.html#a2db9152a4f86289696a72bd13e26e7b9" title="get array/struct size">value::size</a>();          <span class="comment">// get array/struct size</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structvalue.html#a95f0f36dbb5dd05b3fb15a3006f4db36" title="true if empty array or struct">value::empty</a>();        <span class="comment">// empty array/struct</span></div>
</div><!-- fragment --><p>For example, given the value <code>v</code> assigned the array shown above, we have:</p>
<div class="fragment"><div class="line">v.is_array() == <span class="keyword">true</span>;</div>
<div class="line">v.size() == 1;</div>
<div class="line">v[0].is_struct() == <span class="keyword">true</span>;</div>
<div class="line">v[0][<span class="stringliteral">&quot;name&quot;</span>].is_string() == <span class="keyword">true</span>;</div>
</div><!-- fragment --><p>To extract data we can use casts and array/struct indexing on a value <code>v</code> as follows:</p>
<div class="fragment"><div class="line">(int)v</div>
<div class="line">(<span class="keywordtype">double</span>)v</div>
<div class="line">(<span class="keywordtype">char</span>*)v</div>
<div class="line">(<span class="keywordtype">string</span>)v</div>
<div class="line">(<span class="keywordtype">wchar_t</span>*)v                 <span class="comment">// assuming UTF8 XML/JSON</span></div>
<div class="line">(wstring)v                  <span class="comment">// assuming UTF8 XML/JSON</span></div>
<div class="line">(<span class="keywordtype">bool</span>)v</div>
<div class="line">(time_t)v</div>
<div class="line">(<a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>)v</div>
</div><!-- fragment --><p>To access base64 binary raw data of a value <code>v</code>, use:</p>
<div class="fragment"><div class="line"><a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>&amp; bin = v;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *raw = bin.<a class="code" href="struct__base64.html#accb75dbcdaf316a692d92d42783ffcb8" title="pointer to data">ptr</a>();</div>
<div class="line"><span class="keywordtype">int</span> size = bin.<a class="code" href="struct__base64.html#a89555bd2f9d977fd17bc2823bef10230" title="byte size of data">size</a>();</div>
</div><!-- fragment --><p>To traverse arrays and structs, we should use iterators. An iterator has an <code>index()</code> method to obtain the array index (an int) and struct member name (a string). Dereferencing the iterator gives the JSON value in the array or struct located at that index.</p>
<p>For example, to traverse a value <code>v</code> that is an array or a struct:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (v.is_array())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>&amp; vec = v;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="struct__array.html#a61e069daf5d5b31875a5d249216ac8d3">_array::iterator</a> i = vec.<a class="code" href="struct__array.html#ac15280959920d28bf27568d38ee7b6ba" title="array iterator begin">begin</a>(); i != vec.<a class="code" href="struct__array.html#a1f4d85181b117638a22d04925bb386f1" title="array iterator end">end</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> index = i.index();</div>
<div class="line">        <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; array_value = *i;</div>
<div class="line">        ... <span class="comment">// use index and array_value</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (v.is_struct())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>&amp; rec = v;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="struct__struct.html#a88edf40f7bb954061eddc160b1105ff3">_struct::iterator</a> i = rec.<a class="code" href="struct__struct.html#a69e6a472947d4aa911a82a153b9d867a" title="struct accessor iterator begin">begin</a>(); i != rec.<a class="code" href="struct__struct.html#aef253f058f1679add8210023c4f6f8bb" title="struct accessor iterator end">end</a>(); ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *member_name = i.index();</div>
<div class="line">        <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; member_value = *i;</div>
<div class="line">        ... <span class="comment">// use member_name and member_value</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Parameter lists are similar to arrays and its values are indexed. We can also iterate over parameter content of XML-RPC remote methods:</p>
<div class="fragment"><div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> request(ctx, 2);</div>
<div class="line">request[0] = ...;           <span class="comment">// first request parameter</span></div>
<div class="line">request[1] = ...;           <span class="comment">// second request parameter</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="structparams.html#a42e515c9a4bc03a29382e63dddea8496">params::iterator</a> i = response.<a class="code" href="structparams.html#a21b28ad0796dba7d6e00abb4587f7ffa" title="parameter accessor iterator begin">begin</a>(); i != response.<a class="code" href="structparams.html#a4934efffe16d4d367203c1acd0e777ce" title="parameter accessor iterator end">end</a>(); ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> index = i.index();</div>
<div class="line">    <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>&amp; param_value = *i;</div>
<div class="line">    ... <span class="comment">// use param_value of response params</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>There are two additional methods to invoke on parameters:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">params::size</a>();         <span class="comment">// get number of parameters</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">params::empty</a>();       <span class="comment">// true if no parameters</span></div>
</div><!-- fragment --><p>All dynamically allocated memory that is internally used to store data is deallocated with:</p>
<div class="fragment"><div class="line">soap_destroy(ctx);  <span class="comment">// delete objects</span></div>
<div class="line">soap_end(ctx);      <span class="comment">// deallocate temporary data</span></div>
<div class="line">soap_free(ctx);     <span class="comment">// deallocate the context allocated with soap_new()</span></div>
</div><!-- fragment --><h2><a class="anchor" id="cpp-cl"></a>
C++ XML-RPC Client Example                                             </h2>
<p>A typical XML-RPC calling sequence in C++ is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span> <span class="comment">// generated by the command: soapcpp2 -CSL xml-rpc.h</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// Store Unicode in UTF8 format</span></div>
<div class="line"><span class="comment">// create a call object</span></div>
<div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><span class="comment">// create parameter list with 5 values</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> request(ctx, 5);</div>
<div class="line"><span class="comment">// populate parameters</span></div>
<div class="line">request[0] = 123;           <span class="comment">// first parameter is an integer</span></div>
<div class="line">request[1] = <span class="stringliteral">&quot;abc&quot;</span>;         <span class="comment">// second is a string</span></div>
<div class="line">request[2][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;joe&quot;</span>; <span class="comment">// a record, first member &quot;name&quot;</span></div>
<div class="line">request[2][<span class="stringliteral">&quot;age&quot;</span>] = 23;     <span class="comment">// a record, second member &quot;age&quot;</span></div>
<div class="line">request[3][0] = 456.789;    <span class="comment">// an array, first element (a float)</span></div>
<div class="line">request[3][1] = <span class="stringliteral">&quot;widget&quot;</span>;   <span class="comment">// an array, second element (a string)</span></div>
<div class="line">request[3][2] = <span class="keyword">true</span>;       <span class="comment">// an array, third element (a bool)</span></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> record(ctx);          <span class="comment">// another struct</span></div>
<div class="line">record[<span class="stringliteral">&quot;foo&quot;</span>] = 1;</div>
<div class="line">record[<span class="stringliteral">&quot;bar&quot;</span>] = 2;</div>
<div class="line">request[4] = record;        <span class="comment">// assign record to parameter</span></div>
<div class="line"><span class="comment">// get list of parameters by making the XML-RPC call</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);</div>
<div class="line"><span class="comment">// check result</span></div>
<div class="line"><span class="keywordflow">if</span> (rpc.error())</div>
<div class="line">    soap_print_fault(ctx, stderr);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response.<a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">empty</a>())</div>
<div class="line">    printf(<span class="stringliteral">&quot;No response data\n&quot;</span>);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>() &gt; 1)</div>
<div class="line">    printf(<span class="stringliteral">&quot;More than one response data\n&quot;</span>);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_array() &amp;&amp; !response[0].<a class="code" href="structparams.html#af65f66c853166bc136578dffdde31316" title="true if no parameters">empty</a>())</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response[0].<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>())</div>
<div class="line">        ... = response[0][i];</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_struct())</div>
<div class="line">{</div>
<div class="line">    ... = response[0][<span class="stringliteral">&quot;membername1&quot;</span>];</div>
<div class="line">    ... = response[0][<span class="stringliteral">&quot;membername2&quot;</span>];</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_base64())</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a> raw&amp; = response[0];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *raw = bin.<a class="code" href="struct__base64.html#accb75dbcdaf316a692d92d42783ffcb8" title="pointer to data">ptr</a>();</div>
<div class="line">    <span class="keywordtype">int</span> size = bin.<a class="code" href="struct__base64.html#a89555bd2f9d977fd17bc2823bef10230" title="byte size of data">size</a>();</div>
<div class="line">    ... <span class="comment">// use raw[0..size-1] data</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_bool())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> flag = response[0];</div>
<div class="line">    ... <span class="comment">// use boolean flag</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_int())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> num = response[0];</div>
<div class="line">    ... <span class="comment">// use integer</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_double())</div>
<div class="line">{   <span class="keywordtype">double</span> num = response[0];</div>
<div class="line">    ... <span class="comment">// use double float</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_string())</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *str = response[0];</div>
<div class="line">    <span class="comment">// use string, note that also legal is:</span></div>
<div class="line">    <span class="keyword">const</span> std::string&amp; st = response[0];</div>
<div class="line">    <span class="comment">// and conversion from UTF8 to wide string unicode:</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *w = response[0];</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; ws = response[0];</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (response[0].is_dateTime())</div>
<div class="line">{</div>
<div class="line">    time_t t = response[0];</div>
<div class="line">    ... <span class="comment">// use time</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// deallocate all</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>Alternatively when desired, the parameters of the <a class="el" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> object can be directly populated as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx, <span class="stringliteral">&quot;endpoint URL&quot;</span>, <span class="stringliteral">&quot;methodName&quot;</span>);</div>
<div class="line"><span class="comment">// populate parameters</span></div>
<div class="line">rpc[0] = 123;           <span class="comment">// first parameter is an integer</span></div>
<div class="line">rpc[1] = <span class="stringliteral">&quot;abc&quot;</span>;         <span class="comment">// second is a string</span></div>
<div class="line">rpc[2][<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;joe&quot;</span>; <span class="comment">// a record, first member &quot;name&quot;</span></div>
<div class="line">rpc[2][<span class="stringliteral">&quot;age&quot;</span>] = 23;     <span class="comment">// a record, second member &quot;age&quot;</span></div>
<div class="line">rpc[3][0] = 456.789;    <span class="comment">// an array, first element (a float)</span></div>
<div class="line">rpc[3][1] = <span class="stringliteral">&quot;widget&quot;</span>;   <span class="comment">// an array, second element (a string)</span></div>
<div class="line">rpc[3][2] = <span class="keyword">true</span>;       <span class="comment">// an array, third element (a bool)</span></div>
<div class="line">rpc[4][<span class="stringliteral">&quot;foo&quot;</span>] = 1;</div>
<div class="line">rpc[4][<span class="stringliteral">&quot;bar&quot;</span>] = 2;</div>
<div class="line"><span class="comment">// get list of parameters by making the XML-RPC call</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
</div><!-- fragment --><p>Note that in the client code, after the response is retrieved, the implicit type casts done by assignments extract the values. These casts can be used anywhere to extract values:</p>
<div class="fragment"><div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
<div class="line"><span class="keywordtype">double</span> sum = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>(); i++)</div>
<div class="line">    <span class="keywordflow">if</span> (response[i].is_double())    <span class="comment">// is this parameter a double float?</span></div>
<div class="line">        sum += (<span class="keywordtype">double</span>)response[i];</div>
</div><!-- fragment --><p>Type casts can also be used to convert data, which means they never produce an exception. Casting to string <code>(const char*)</code> converts atomic values and base64 data to strings, but does not convert compound types such as arrays and structs.</p>
<div class="fragment"><div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; response.<a class="code" href="structparams.html#a6e150e3958d176f05bd6579d5d14836c" title="number of parameters">size</a>(); i++)</div>
<div class="line">    printf(<span class="stringliteral">&quot;response[%d] = %s\n&quot;</span>, i, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)response[i]);</div>
</div><!-- fragment --><p>which prints a string representation of the int, double, boolean, time, or base64 values of parameters. An empty string is printed for arrays and structs. Use iterators to walk over arrays and structs to print values. Or use the JSON module to print values in JSON format, see further on JSON below.</p>
<h2><a class="anchor" id="cpp-sr"></a>
C++ XML-RPC Server Example                                             </h2>
<p>A typical C++ XML-RPC server sequence is:</p>
<div class="fragment"><div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><span class="comment">// create a method object</span></div>
<div class="line"><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx);</div>
<div class="line"><span class="comment">// option 1: parse and write to/from stdin/out</span></div>
<div class="line"><span class="comment">// (no code needed)</span></div>
<div class="line"><span class="comment">// option 2: parse and write to/from FILE</span></div>
<div class="line"><span class="comment">// ctx-&gt;recvfd = ...; // set input FD</span></div>
<div class="line"><span class="comment">// ctx-&gt;sendfd = ...; // set output FD</span></div>
<div class="line"><span class="comment">// option 3: parse and write to/from IO streams</span></div>
<div class="line"><span class="comment">// ctx-&gt;is = ...; // set input stream</span></div>
<div class="line"><span class="comment">// ctx-&gt;os = ...; // set output stream</span></div>
<div class="line"><span class="keywordflow">if</span> (rpc.recv() != SOAP_OK)</div>
<div class="line">    soap_print_fault(ctx, stderr);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// create response</span></div>
<div class="line">    <a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> response(ctx);</div>
<div class="line">    <span class="comment">// check method name</span></div>
<div class="line">    <span class="keywordflow">if</span> (!strcmp(rpc.name(), <span class="stringliteral">&quot;methodName&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// method name matches: populate response parameters with values:</span></div>
<div class="line">        response[0] = ...;</div>
<div class="line">        response[1] = ...;</div>
<div class="line">        ... <span class="comment">// add response data </span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// otherwise, set fault</span></div>
<div class="line">        response.set_fault(<span class="stringliteral">&quot;Wrong method&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// send response</span></div>
<div class="line">    <span class="keywordflow">if</span> (response.send() != SOAP_OK)</div>
<div class="line">        soap_print_fault(ctx, stderr);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// close (but keep-alive setting keeps socket open)</span></div>
<div class="line">soap_closesock(ctx);</div>
<div class="line"><span class="comment">// clean up</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line"><span class="comment">// free context (but we can reuse it to serve next call)</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>With option 1 the server code above uses standard in/out and thus runs over CGI. Other possibilities are given by options 2 and 3.</p>
<p>To serve requests at a port, we use the <code>soap_bind()</code> and <code>soap_accept()</code> calls to bind the server to a port and accept requests via socket, see also the docs and examples for these calls (e.g. samples/webserver.c):</p>
<div class="fragment"><div class="line"><span class="comment">// create an allocation context</span></div>
<div class="line">soap *ctx = soap_new1(SOAP_IO_KEEPALIVE | SOAP_C_UTFSTRING);</div>
<div class="line"><span class="comment">// bind to port 8080</span></div>
<div class="line"><span class="keywordflow">if</span> (!soap_valid_socket(soap_bind(ctx, NULL, 8080, 100)))</div>
<div class="line">    ... <span class="comment">// error, stop</span></div>
<div class="line"><span class="comment">// accept messages in server loop</span></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!soap_valid_socket(soap_accept(ctx)))</div>
<div class="line">        ... <span class="comment">// error, stop</span></div>
<div class="line">    <span class="comment">// create a method object</span></div>
<div class="line">    <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> rpc(ctx);</div>
<div class="line">    <span class="comment">// parse it from socket</span></div>
<div class="line">    <span class="keywordflow">if</span> (rpc.recv() != SOAP_OK)</div>
<div class="line">        soap_print_fault(ctx, stderr);</div>
<div class="line">    ... <span class="comment">// process request, produce result to send as shown above</span></div>
<div class="line">    <span class="comment">// close (but keep-alive setting keeps socket open)</span></div>
<div class="line">    soap_closesock(ctx);</div>
<div class="line">    <span class="comment">// clean up</span></div>
<div class="line">    soap_destroy(ctx);</div>
<div class="line">    soap_end(ctx);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// free context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><h2><a class="anchor" id="cpp-io"></a>
C++ XML-RPC Data Serialization from/to Streams                         </h2>
<p>To send and receive XML over streams, use <code>xml-rpc-io.h</code> and <code>xml-rpc-io.cpp</code>. For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;xml-rpc-io.h&quot;</span> <span class="comment">// also compile and link xml-rpc-io.cpp</span></div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; response[0] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>which will display the data in XML-RPC format. To parse XML-RPC data from a stream, use:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;xml-rpc-io.h&quot;</span> <span class="comment">// also compile and link xml-rpc-io.cpp</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v(ctx);</div>
<div class="line">std::cin &gt;&gt; v;</div>
</div><!-- fragment --><h2><a class="anchor" id="cpp-js"></a>
C++ JSON Serialization from/to Streams                                 </h2>
<p>To display values in JSON format or to parse JSON data, use the <a class="el" href="json_8h.html">json.h</a> and json.cpp JSON serializers in combination with xml-rpc.cpp and the auto-generated soapH.h and soapC.cpp. It is also possible to send and receive JSON data over HTTP as JSON-RPC operations, but this requires some more coding (see <a href="#cpp-jr">JSON-RPC over HTTP</a> below).</p>
<p>Because the internal data is the same for XML-RPC and JSON, You can dump data in XML-RPC or in JSON format. You can also parse XML-RPC data and dump to JSON data and vice versa.</p>
<p>For example, we can parse a JSON-formatted string and use that data to make an XML-RPC call:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span> <span class="comment">// also compile and link soapC.cpp and xml-rpc.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span>  <span class="comment">// also compile and link json.cpp for JSON serialization</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// UTF8 in char*/std::string</span></div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx);</div>
<div class="line">istringstream in;</div>
<div class="line">in.str(<span class="stringliteral">&quot;[ [1, \&quot;2\&quot;, 3.14, true], {\&quot;name\&quot;: \&quot;john\&quot;, \&quot;age\&quot;: 24} ]&quot;</span>);</div>
<div class="line">in &gt;&gt; request;                      <span class="comment">// parse JSON, store as XML-PRC data</span></div>
<div class="line"><a class="code" href="structparams.html" title="Represents the &lt;params&gt; of a &lt;methodCall&gt; request and response.">params</a> response = rpc(request);     <span class="comment">// make the XML-RPC call</span></div>
<div class="line">std::cout &lt;&lt; response &lt;&lt; std::endl; <span class="comment">// display result in JSON</span></div>
</div><!-- fragment --><p>The JSON protocol has fewer data types than XML-RPC, so type information can be lost when serializing to JSON:</p>
<ul>
<li>XML-RPC distinguishes ints from floats while JSON only supports floats. Ints are converted to double floats by the JSON serializer.</li>
<li>XML-RPC has a dateTime type, JSON does not. The JSON serializer converts the dateTime type to a dateTime-formatted string.</li>
<li>XML-RPC uses a base64 type to exchange raw binary data. The base64 data is converted to a string with base64 content by the JSON serializer.</li>
</ul>
<p>See the section on C++ Examples on how to populate and extract C++ data.</p>
<p>Strings are stored and exchanged in UTF8 format in 8-bit strings (<code>char*</code> and <code>std::string</code>) by using the <code>SOAP_C_UTFSTRING</code> flag. Without this flag, 8-bit strings are converted to UTF8. By contrast, wide character strings use unicode.</p>
<p>To force reading and writing JSON in ISO 8859-1 format from UTF8 strings, use the <code>SOAP_ENC_LATIN</code> flag to set the context.</p>
<h2><a class="anchor" id="cpp-jr"></a>
C++ JSON-RPC over HTTP (REST method)                                   </h2>
<p>To invoke JSON-RPC over HTTP on the client side, use <code>json_call</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span>           <span class="comment">// also compile and link soapC.cpp, xml-rpc.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span>            <span class="comment">// also compile and link json.cpp</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line">soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx), response(ctx);</div>
<div class="line"><span class="comment">// now populate the &#39;request&#39; data to send</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="json_8h.html#a35e61d508bfe781f609b5dfa72bbbfd9" title="Client-side JSON-RPC call.">json_call</a>(ctx, <span class="stringliteral">&quot;URL&quot;</span>, request, response) != SOAP_OK))</div>
<div class="line">  ... <span class="comment">// error</span></div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  ... <span class="comment">// use the &#39;response&#39; data response</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// dealloc objects and temp data</span></div>
<div class="line">soap_destroy(ctx);</div>
<div class="line">soap_end(ctx);</div>
<div class="line">... <span class="comment">// make other calls etc.</span></div>
<div class="line"><span class="comment">// dealloc context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --><p>To implement a JSON-RPC server for CGI (e.g. install in cgi-bin):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span>           <span class="comment">// also compile and link soapC.cpp, xml-rpc.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json_8h.html">json.h</a>&quot;</span>            <span class="comment">// also compile and link json.cpp</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{ soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line">  <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request(ctx), response(ctx);</div>
<div class="line">  <span class="keywordflow">if</span> (soap_begin_recv(ctx)</div>
<div class="line">   || <a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, request)</div>
<div class="line">   || soap_end_recv(ctx))</div>
<div class="line">    soap_send_fault(ctx);</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  { ... <span class="comment">// use the &#39;request&#39; value</span></div>
<div class="line">    ... <span class="comment">// set the &#39;response&#39; value</span></div>
<div class="line">    <span class="comment">// set http content type</span></div>
<div class="line">    ctx-&gt;http_content = <span class="stringliteral">&quot;application/json; charset=utf-8&quot;</span>;</div>
<div class="line">    <span class="comment">// send http header and body</span></div>
<div class="line">    <span class="keywordflow">if</span> (soap_response(ctx, SOAP_FILE)</div>
<div class="line">     || <a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, response)</div>
<div class="line">     || soap_end_send(ctx))</div>
<div class="line">      soap_print_fault(ctx, stdout);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// dealloc all</span></div>
<div class="line">  soap_destroy(ctx);</div>
<div class="line">  soap_end(ctx);</div>
<div class="line">  soap_free(ctx);</div>
<div class="line">}</div>
</div><!-- fragment --><p>For client and server examples, please see the gSOAP package content:</p>
<ul>
<li><code>gsoap/samples/xml-rpc-json/json-currentTime.cpp</code></li>
<li><code>gsoap/samples/xml-rpc-json/json-currentTimeServer.cpp</code></li>
</ul>
<h1><a class="anchor" id="c"></a>
C XML-RPC and JSON                                                          </h1>
<p>The following source files are provided for XML-RPC support in C:</p>
<ul>
<li><code><a class="el" href="xml-rpc_8h.html">xml-rpc.h</a></code>: XML-RPC binding as a gSOAP .h file for soapcpp2 (do not #include this file in your project builds)</li>
</ul>
<p>For JSON serialization, use the following files instead of xml-rpc-io.h and xml-rpc-io.cpp:</p>
<ul>
<li><code><a class="el" href="json__c_8h.html">json_c.h</a></code>: C JSON serializer</li>
<li><code>json_c.c</code>: C JSON serializer</li>
</ul>
<p>For JSON-RPC over HTTP (JSON REST method), please use the <code>plugin/httppost.c</code> plugin. See <a href="#c-jr">JSON-RPC over HTTP</a> explanation below.</p>
<p>Note that <code>soapH.h</code>, <code>soapStub.h</code>, and <code>soapC.c</code> are required for XML-RPC and JSON. To generate these C files, you need to execute: </p>
<pre class="fragment">soapcpp2 -c -CSL xml-rpc.h
</pre><p>Also compile and link with <code>stdsoap2.c</code> (or link with <code>libgsoap.a</code> installed by the gSOAP package).</p>
<h2><a class="anchor" id="c-ex"></a>
C Examples                                                               </h2>
<p>Examples are provided in the software package:</p>
<ul>
<li><code>xml-rpc-currentTime.c</code>: client in C</li>
<li><code>xml-rpc-weblogs.c</code>: client in C</li>
</ul>
<p>All XML-RPC and JSON message manipulation is done at a very low-level.</p>
<h2><a class="anchor" id="c-cl"></a>
C XML-RPC Client Example                                                 </h2>
<p>An XML RPC call is made using the following function that you can define for your convenience:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;soapH.h&quot;</span> <span class="comment">// generated by the command: soapcpp2 -c -CSL xml-rpc.h</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a>(<span class="keyword">struct</span> soap *ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *URL, <span class="keyword">struct</span> <a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> *m, <span class="keyword">struct</span> <a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> *r)</div>
<div class="line">{   <span class="comment">/* no namespaces */</span></div>
<div class="line">    ctx-&gt;namespaces = NULL;</div>
<div class="line">    <span class="comment">/* no SOAP encodingStyle */</span></div>
<div class="line">    ctx-&gt;encodingStyle = NULL;</div>
<div class="line">    <span class="comment">/* connect, send request, and receive response */</span></div>
<div class="line">    <span class="keywordflow">if</span> (soap_connect(ctx, URL, NULL)</div>
<div class="line">     || soap_begin_send(ctx)</div>
<div class="line">     || soap_put_methodCall(ctx, m, <span class="stringliteral">&quot;methodCall&quot;</span>, NULL)</div>
<div class="line">     || soap_end_send(ctx)</div>
<div class="line">     || soap_begin_recv(ctx)</div>
<div class="line">     || !soap_get_methodResponse(ctx, r, <span class="stringliteral">&quot;methodResponse&quot;</span>, NULL)</div>
<div class="line">     || soap_end_recv(ctx))</div>
<div class="line">        <span class="keywordflow">return</span> soap_closesock(ctx); <span class="comment">/* closes socket and returns error */</span></div>
<div class="line">    soap_closesock(ctx);</div>
<div class="line">    <span class="keywordflow">return</span> SOAP_OK;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then use this XML-RPC method caller in C as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">/* store UTF8 in char* */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a> m;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmethod_response.html" title="Represents the &lt;methodResponse&gt; element with response &lt;params&gt; and &lt;fault&gt;.">methodResponse</a> r;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structparam.html" title="Represents a &lt;param&gt; of the &lt;params&gt; of a &lt;methodCall&gt;.">param</a> p[4];  <span class="comment">/* method has four parameters to send */</span></div>
<div class="line"><span class="keywordtype">int</span> n;              <span class="comment">/* an int */</span></div>
<div class="line"><span class="keywordtype">double</span> x;           <span class="comment">/* a float */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a> s;   <span class="comment">/* a struct ... */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structmember.html" title="Represents the &lt;member&gt; element of a &lt;struct&gt;.">member</a> f[2]; <span class="comment">/* ... with 2 members */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a> a;    <span class="comment">/* an array ... */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v[2];  <span class="comment">/* ... with 2 values */</span></div>
<div class="line"><a class="code" href="xml-rpc_8h.html#a7d938291b52a0161e5fae7b812697c00" title="Scalar &lt;boolean&gt; element with values 0 (false) or 1 (true)">_boolean</a> <a class="code" href="json__c_8h.html#acce7277a58428ea88d62d2e5844fbc31">False</a> = 0, <a class="code" href="json__c_8h.html#ac6ae2bed188396fcbc0900db22b2563f">True</a> = 1;</div>
<div class="line"><span class="comment">/* Set up method call */</span></div>
<div class="line">m.<a class="code" href="structmethod_call.html#abc8679693ba8ba246acd5efa0c22a04f" title="name of the method">methodName</a> = <span class="stringliteral">&quot;methodName&quot;</span>;</div>
<div class="line"><span class="comment">/* set the four parameters */</span></div>
<div class="line">m.<a class="code" href="structmethod_call.html#ab912ec3d3c7e376e88000527c8a8cbf7" title="method request parameters">params</a>.<a class="code" href="structparams.html#a06e3329b37920ec9a0ed8a97cece2835" title="number of parameters">__size</a> = 4;</div>
<div class="line">m.<a class="code" href="structmethod_call.html#ab912ec3d3c7e376e88000527c8a8cbf7" title="method request parameters">params</a>.<a class="code" href="structparams.html#a3d0af80a29239c8cb042d84ed52ea9f8" title="pointer to array of parameters">param</a> = p;</div>
<div class="line">memset(p, 0, <span class="keyword">sizeof</span>(p));</div>
<div class="line">p[0].value.__type = SOAP_TYPE__string;</div>
<div class="line">p[0].value.ref = <span class="stringliteral">&quot;a string parameter&quot;</span>;</div>
<div class="line">p[1].value.__type = SOAP_TYPE__int;</div>
<div class="line">p[1].value.ref = &amp;n;</div>
<div class="line">n = 123;</div>
<div class="line">p[2].value.__type = SOAP_TYPE__double;</div>
<div class="line">p[2].value.ref = &amp;x;</div>
<div class="line">x = 4.56;</div>
<div class="line">p[3].value.__type = SOAP_TYPE__struct;</div>
<div class="line">p[3].value.ref = &amp;s;</div>
<div class="line">memset(&amp;s, 0, <span class="keyword">sizeof</span>(s));</div>
<div class="line">s.__size = 2;</div>
<div class="line">s.member = f;</div>
<div class="line">memset(f, 0, <span class="keyword">sizeof</span>(f));</div>
<div class="line">f[0].name = <span class="stringliteral">&quot;memberName1&quot;</span>;</div>
<div class="line">f[0].value.__type = SOAP_TYPE__boolean;</div>
<div class="line">f[0].value.ref = &amp;<a class="code" href="json__c_8h.html#ac6ae2bed188396fcbc0900db22b2563f">True</a>;</div>
<div class="line">f[1].name = <span class="stringliteral">&quot;memberName2&quot;</span>;</div>
<div class="line">f[0].value.__type = SOAP_TYPE__array;</div>
<div class="line">f[0].value.ref = &amp;a;</div>
<div class="line">memset(&amp;a, 0, <span class="keyword">sizeof</span>(a));</div>
<div class="line">a.data.__size = 2;</div>
<div class="line">a.data.value = v;</div>
<div class="line">memset(v, 0, <span class="keyword">sizeof</span>(v));</div>
<div class="line">v[0].__type = SOAP_TYPE__string;</div>
<div class="line">v[0].ref = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line">v[1].__type = SOAP_TYPE__string;</div>
<div class="line">v[1].ref = <span class="stringliteral">&quot;world&quot;</span>;</div>
<div class="line"><span class="comment">/* connect, send request, and receive response */</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="structmethod_call.html" title="Represents the &lt;methodCall&gt; element with &lt;methodName&gt; and request &lt;params&gt; for remote invocation...">methodCall</a>(ctx, <span class="stringliteral">&quot;http://domain/path/service&quot;</span>, &amp;m, &amp;r))</div>
<div class="line">{   soap_print_fault(ctx, stderr);</div>
<div class="line">    exit(ctx-&gt;error);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (r.<a class="code" href="structmethod_response.html#a12cde024598eca0591034800c5e5396c" title="response fault">fault</a>)</div>
<div class="line">{   <span class="comment">/* print fault on stdout */</span></div>
<div class="line">    soap_begin_send(ctx);</div>
<div class="line">    soap_put_fault(ctx, r.<a class="code" href="structmethod_response.html#a12cde024598eca0591034800c5e5396c" title="response fault">fault</a>, <span class="stringliteral">&quot;fault&quot;</span>, NULL);</div>
<div class="line">    soap_end_send(ctx);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{   <span class="comment">/* print response parameters */</span></div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; r.<a class="code" href="structmethod_response.html#aa7ce822e433441be354b3667876786be" title="response parameters">params</a>-&gt;<a class="code" href="structparams.html#a06e3329b37920ec9a0ed8a97cece2835" title="number of parameters">__size</a>; i++)</div>
<div class="line">    {   printf(<span class="stringliteral">&quot;Return parameter %d = &quot;</span>, i+1);</div>
<div class="line">        display(&amp;r.<a class="code" href="structmethod_response.html#aa7ce822e433441be354b3667876786be" title="response parameters">params</a>-&gt;<a class="code" href="structparams.html#a3d0af80a29239c8cb042d84ed52ea9f8" title="pointer to array of parameters">param</a>[i].<a class="code" href="structparam.html#a090957e613e95786c9328afc15651c60" title="parameter value">value</a>); <span class="comment">/* SEE BELOW */</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To dynamically allocate data for automatic deallocation by the gSOAP engine, use <code>soap_malloc(ctx, size)</code>, for example as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> *v = soap_malloc(ctx, 2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>));</div>
<div class="line">memset(v, 0, 2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a>));</div>
<div class="line"></div>
<div class="line">soap_end(ctx); <span class="comment">/* deallocate all */</span></div>
</div><!-- fragment --><p>See <code>xml-rpc-currentTime.c</code> and <code>xml-rpc-weblogs.c</code> for example C code.</p>
<p>A convenient way to display XML RPC data can be implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> display(<span class="keyword">struct</span> <a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> *v)</div>
<div class="line">{   <span class="keywordtype">int</span> i;</div>
<div class="line">    <span class="keywordflow">switch</span> (v-&gt;<a class="code" href="structvalue.html#a5f111b2916de3127c723bd7e74e392df" title="optional SOAP_TYPE_X, where X is a type name">__type</a>)</div>
<div class="line">    {   <span class="keywordflow">case</span> SOAP_TYPE__boolean:</div>
<div class="line">            printf(*((<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>) ? <span class="stringliteral">&quot;TRUE&quot;</span> : <span class="stringliteral">&quot;FALSE&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__double:</div>
<div class="line">            printf(<span class="stringliteral">&quot;%g&quot;</span>, *((<span class="keywordtype">double</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>));</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__i4:</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__int:</div>
<div class="line">            printf(<span class="stringliteral">&quot;%d&quot;</span>, *((<span class="keywordtype">int</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>));</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__dateTime_DOTiso8601:</div>
<div class="line">            printf(<span class="stringliteral">&quot;%s&quot;</span>, (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__string:</div>
<div class="line">            printf(<span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__base64:</div>
<div class="line">            printf(<span class="stringliteral">&quot;[%d bytes of raw data at %p]&quot;</span>,</div>
<div class="line">                ((<span class="keyword">struct</span> <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__size,</div>
<div class="line">                ((<span class="keyword">struct</span> <a class="code" href="struct__base64.html" title="Represents the &lt;base64&gt; binary data element.">_base64</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__ptr);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__struct:</div>
<div class="line">            printf(<span class="stringliteral">&quot;{\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">for</span> (i = 0; i &lt; ((<span class="keyword">struct </span><a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;__size; i++)</div>
<div class="line">            {   printf(<span class="stringliteral">&quot;\&quot;%s\&quot;:&quot;</span>, ((<span class="keyword">struct</span> <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;member[i].name);</div>
<div class="line">                display(&amp;((<span class="keyword">struct</span> <a class="code" href="struct__struct.html" title="Represents the &lt;struct&gt; record structure element.">_struct</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;member[i].value);</div>
<div class="line">                printf(<span class="stringliteral">&quot;,\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            printf(<span class="stringliteral">&quot;}\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> SOAP_TYPE__array:</div>
<div class="line">            printf(<span class="stringliteral">&quot;[\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">for</span> (i = 0; i &lt; ((<span class="keyword">struct </span><a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;data.__size; i++)</div>
<div class="line">            {   display(&amp;((<span class="keyword">struct</span> <a class="code" href="struct__array.html" title="Represents the &lt;array&gt; array of values element.">_array</a>*)v-&gt;<a class="code" href="structvalue.html#a9d8bdea6bebd0043f1ff58b9a8a38d7c" title="ref to data">ref</a>)-&gt;data.value[i]);</div>
<div class="line">                printf(<span class="stringliteral">&quot;,\n&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            printf(<span class="stringliteral">&quot;]\n&quot;</span>);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">if</span> (!v-&gt;<a class="code" href="structvalue.html#a5f111b2916de3127c723bd7e74e392df" title="optional SOAP_TYPE_X, where X is a type name">__type</a>)</div>
<div class="line">                printf(<span class="stringliteral">&quot;\&quot;%s\&quot;&quot;</span>, v-&gt;<a class="code" href="structvalue.html#ad1ba4e5292336e96e96871a76fae13ab" title="&lt;value&gt; string content, when present">__any</a>);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                printf(<span class="stringliteral">&quot;{?}&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="c-js"></a>
C JSON Serialization                                                     </h2>
<p>To display values in JSON format or parse JSON data, use the <code><a class="el" href="json__c_8h.html">json_c.h</a></code> and <code>json_c.c</code> JSON serializers. It is also possible to send and receive JSON data over HTTP.</p>
<p>You can dump the XML-RPC data in JSON or populate XML-RPC from JSON data, because the data stored in C is independent of XML-RPC and JSON formats.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json__c_8h.html">json_c.h</a>&quot;</span> <span class="comment">// also compile and link json.cpp for JSON serialization</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> v;</div>
<div class="line"></div>
<div class="line">ctx-&gt;recvfd = ...;          <span class="comment">// set file descriptor</span></div>
<div class="line"><a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, &amp;v);         <span class="comment">// parse JSON, store as XML-PRC data</span></div>
<div class="line"></div>
<div class="line">ctx-&gt;sendfd = ...;          <span class="comment">// set file descriptor</span></div>
<div class="line"><a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, &amp;v);         <span class="comment">// output JSON value</span></div>
</div><!-- fragment --><p>The JSON protocol has fewer data types than XML-RPC, so type information can be lost when serializing to JSON:</p>
<ul>
<li>XML-RPC distinguishes ints from floats while JSON only supports floats. Ints are converted to double floats by the JSON serializer.</li>
<li>XML-RPC has a dateTime type, JSON does not. The JSON serializer converts the dateTime type to a dateTime-formatted string.</li>
<li>XML-RPC uses a base64 type to exchange raw binary data. The base64 data is converted to a string with base64 content by the JSON serializer.</li>
</ul>
<p>See the section on C++ Examples on how to populate and extract C++ data.</p>
<p>Strings are stored and exchanged in UTF8 format in 8-bit strings (<code>char*</code>) by using the <code>SOAP_C_UTFSTRING</code> flag. Without this flag, 8-bit strings are converted to UTF8. By contrast, wide character strings use unicode.</p>
<p>To force reading and writing JSON in ISO 8859-1 format from UTF8 strings, use the <code>SOAP_ENC_LATIN</code> flag to set the context.</p>
<h2><a class="anchor" id="c-jr"></a>
C JSON-RPC over HTTP (REST method)                                       </h2>
<p>To serialize JSON over HTTP as a client application, use <code>plugin/httppost.c</code>, for example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;plugin/httppost.h&quot;</span>  <span class="comment">// also compile and link plugin/httppost.c</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="json__c_8h.html">json_c.h</a>&quot;</span>           <span class="comment">// also compile and link json_c.c</span></div>
<div class="line"><span class="keyword">struct </span>Namespace namespaces[] = { {NULL, NULL} }; <span class="comment">// no XML namespaces</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>soap *ctx = soap_new1(SOAP_C_UTFSTRING); <span class="comment">// UTF8 in char*/std::string</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> request;</div>
<div class="line">... <span class="comment">// now populate the &#39;request&#39; data to be send</span></div>
<div class="line"><span class="keywordflow">if</span> (soap_post_connect(ctx, <span class="stringliteral">&quot;URL&quot;</span>, NULL, <span class="stringliteral">&quot;application/json&quot;</span>)</div>
<div class="line"> || <a class="code" href="json_8h.html#a57d66615d6ad549bafa44a3a14c77511">json_send</a>(ctx, request)</div>
<div class="line"> || soap_end_send(ctx))</div>
<div class="line">    ... <span class="comment">// error</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structvalue.html" title="Represents the &lt;value&gt; container element.">value</a> response;</div>
<div class="line"><span class="keywordflow">if</span> (soap_begin_recv(ctx)</div>
<div class="line"> || <a class="code" href="json_8h.html#a9ff2a0fee68897b59e0b30ce64259b99">json_recv</a>(ctx, response)</div>
<div class="line"> || soap_end_recv(ctx))</div>
<div class="line">    ... <span class="comment">// error</span></div>
<div class="line">... <span class="comment">// use the &#39;response&#39; data response</span></div>
<div class="line"><span class="comment">// dealloc objects and temp data</span></div>
<div class="line">soap_end(ctx);</div>
<div class="line">... <span class="comment">// make other calls etc.</span></div>
<div class="line"><span class="comment">// dealloc context</span></div>
<div class="line">soap_free(ctx);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 20 2015 16:31:01 for gSOAP XML-RPC and JSON by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
