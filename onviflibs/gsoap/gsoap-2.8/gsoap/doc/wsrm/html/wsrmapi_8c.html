<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>gSOAP WS-ReliableMessaging: wsrmapi.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gSOAP WS-ReliableMessaging
   &#160;<span id="projectnumber">2.8 Stable</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b4c3aec6cd8f28418150dce663061cfa.html">plugin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">wsrmapi.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="wsrmapi_8h.html">wsrmapi.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for wsrmapi.c:</div>
<div class="dyncontent">
<div class="center"><img src="wsrmapi_8c__incl.png" border="0" usemap="#wsrmapi_8c" alt=""/></div>
<map name="wsrmapi_8c" id="wsrmapi_8c">
<area shape="rect" id="node3" href="wsrmapi_8h.html" title="wsrmapi.h" alt="" coords="100,83,181,111"/><area shape="rect" id="node5" href="wsaapi_8h.html" title="wsaapi.h" alt="" coords="4,161,77,189"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae217764567f04ef0b1e2a208f8e62d66"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae217764567f04ef0b1e2a208f8e62d66">soap_wsrm_init</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, void *arg)</td></tr>
<tr class="memdesc:ae217764567f04ef0b1e2a208f8e62d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes plugin data.  <a href="#ae217764567f04ef0b1e2a208f8e62d66"></a><br/></td></tr>
<tr class="separator:ae217764567f04ef0b1e2a208f8e62d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f296f96d8787a1f864a5d3562250f0a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a4f296f96d8787a1f864a5d3562250f0a">soap_wsrm_copy</a> (struct soap *soap, struct soap_plugin *p, struct soap_plugin *q)</td></tr>
<tr class="memdesc:a4f296f96d8787a1f864a5d3562250f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy plugin data (private thread data).  <a href="#a4f296f96d8787a1f864a5d3562250f0a"></a><br/></td></tr>
<tr class="separator:a4f296f96d8787a1f864a5d3562250f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeafbbe659550e4055c3f49aa564f5c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#adfeafbbe659550e4055c3f49aa564f5c">soap_wsrm_delete</a> (struct soap *soap, struct soap_plugin *p)</td></tr>
<tr class="memdesc:adfeafbbe659550e4055c3f49aa564f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes plugin data.  <a href="#adfeafbbe659550e4055c3f49aa564f5c"></a><br/></td></tr>
<tr class="separator:adfeafbbe659550e4055c3f49aa564f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ff6d902d415e409bd46096022e1eac"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac">soap_wsrm_send</a> (struct soap *soap, const char *buf, size_t len)</td></tr>
<tr class="memdesc:ac7ff6d902d415e409bd46096022e1eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to the current sequence that is created at the client side. Allows unacknowledged messages to be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a>.  <a href="#ac7ff6d902d415e409bd46096022e1eac"></a><br/></td></tr>
<tr class="separator:ac7ff6d902d415e409bd46096022e1eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff41127e3a1960010dd0eed252a1779"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aaff41127e3a1960010dd0eed252a1779">soap_wsrm_preparefinalrecv</a> (struct soap *soap)</td></tr>
<tr class="memdesc:aaff41127e3a1960010dd0eed252a1779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fpreparefinalrecv(). Takes acks returned by response to update the states of the sequences with acknowledgements. Acknowledged messages do not have to be resend and are purged from the sequence states. Also checks if at client-side response message was already received and otherwise records it in the state.  <a href="#aaff41127e3a1960010dd0eed252a1779"></a><br/></td></tr>
<tr class="separator:aaff41127e3a1960010dd0eed252a1779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b48a2e189b15b873083802cafa745a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a37b48a2e189b15b873083802cafa745a">soap_wsrm_disconnect</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a37b48a2e189b15b873083802cafa745a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal callback function to override fdisconnect(). Turns caching off, sets the cached message to NACK, and resets the server-side handle, so sequence can be deallocated later.  <a href="#a37b48a2e189b15b873083802cafa745a"></a><br/></td></tr>
<tr class="separator:a37b48a2e189b15b873083802cafa745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1093d90de46a3170cfc9d980c728a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a3a1093d90de46a3170cfc9d980c728a1">soap_wsrm_process_ack</a> (struct soap *soap, struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *ack)</td></tr>
<tr class="memdesc:a3a1093d90de46a3170cfc9d980c728a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to purge acknowledged messages as given by wsrm:SequenceAcknowledgement header.  <a href="#a3a1093d90de46a3170cfc9d980c728a1"></a><br/></td></tr>
<tr class="separator:a3a1093d90de46a3170cfc9d980c728a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac701708d0b08b663567391421d26501e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ac701708d0b08b663567391421d26501e">soap_wsrm_chk</a> (struct soap *soap, int timeout, int flag)</td></tr>
<tr class="memdesc:ac701708d0b08b663567391421d26501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation.  <a href="#ac701708d0b08b663567391421d26501e"></a><br/></td></tr>
<tr class="separator:ac701708d0b08b663567391421d26501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2eeaf0ead74ae222d5d9eee78c3ed6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aed2eeaf0ead74ae222d5d9eee78c3ed6">soap_wsrm_chk_acks</a> (struct soap *soap)</td></tr>
<tr class="memdesc:aed2eeaf0ead74ae222d5d9eee78c3ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to check for AckRequested headers to update state.  <a href="#aed2eeaf0ead74ae222d5d9eee78c3ed6"></a><br/></td></tr>
<tr class="separator:aed2eeaf0ead74ae222d5d9eee78c3ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7a9a67116baef61a5788136e809c7e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aea7a9a67116baef61a5788136e809c7e">soap_wsrm_add_acks</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 nack, int all, int piggy)</td></tr>
<tr class="memdesc:aea7a9a67116baef61a5788136e809c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to add SequenceAcknowledgement headers for AckRequested. When piggy==0 or internal AcksTo destination is set, sends acknowledgements to the AcksTo destination service or back to the source related to the seq. These sends can take time, which can be controlled with the soap context connect_timeout, send_timeout, recv_timeout settings.  <a href="#aea7a9a67116baef61a5788136e809c7e"></a><br/></td></tr>
<tr class="separator:aea7a9a67116baef61a5788136e809c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e463cf47695a283b6c50d1bec26809"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a89e463cf47695a283b6c50d1bec26809">soap_wsrm_set_ack</a> (struct soap *soap, ULONG64 nack, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *ack)</td></tr>
<tr class="memdesc:a89e463cf47695a283b6c50d1bec26809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function called by <a class="el" href="wsrmapi_8c.html#aea7a9a67116baef61a5788136e809c7e" title="Internal function to add SequenceAcknowledgement headers for AckRequested. When piggy==0 or internal ...">soap_wsrm_add_acks()</a> to populate the SequenceAcknowledgement header block.  <a href="#a89e463cf47695a283b6c50d1bec26809"></a><br/></td></tr>
<tr class="separator:a89e463cf47695a283b6c50d1bec26809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c5cce68cb47b274c3ddb185d7ffb2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aae8c5cce68cb47b274c3ddb185d7ffb2">soap_wsrm_resend_seq</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, int all, ULONG64 lower, ULONG64 upper)</td></tr>
<tr class="memdesc:aae8c5cce68cb47b274c3ddb185d7ffb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to resend unacknowledged messages of a sequence given a range of message numbers. Used by <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a>.  <a href="#aae8c5cce68cb47b274c3ddb185d7ffb2"></a><br/></td></tr>
<tr class="separator:aae8c5cce68cb47b274c3ddb185d7ffb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557d4ee60557fe8a81a7500987135fa7"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a557d4ee60557fe8a81a7500987135fa7">soap_wsrm_seq_newid</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a557d4ee60557fe8a81a7500987135fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to generate a new sequence identifier.  <a href="#a557d4ee60557fe8a81a7500987135fa7"></a><br/></td></tr>
<tr class="separator:a557d4ee60557fe8a81a7500987135fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541a427940ee4da46578b914bb8e279e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a541a427940ee4da46578b914bb8e279e">soap_wsrm_seq_insert_data</a> (struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:a541a427940ee4da46578b914bb8e279e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to insert seq id in hash table for fast lookup.  <a href="#a541a427940ee4da46578b914bb8e279e"></a><br/></td></tr>
<tr class="separator:a541a427940ee4da46578b914bb8e279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c55c813b637be30e1af3f188d1798d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a2c55c813b637be30e1af3f188d1798d5">soap_wsrm_seq_delete_data</a> (struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:a2c55c813b637be30e1af3f188d1798d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to delete seq id from hash table.  <a href="#a2c55c813b637be30e1af3f188d1798d5"></a><br/></td></tr>
<tr class="separator:a2c55c813b637be30e1af3f188d1798d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa04e919fd1a0609363114efd4993d"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a15aa04e919fd1a0609363114efd4993d">soap_wsrm_seq_lookup_data</a> (const char *id)</td></tr>
<tr class="memdesc:a15aa04e919fd1a0609363114efd4993d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up sequence given its id.  <a href="#a15aa04e919fd1a0609363114efd4993d"></a><br/></td></tr>
<tr class="separator:a15aa04e919fd1a0609363114efd4993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80aeab5766416ae37b0c550a756fcf5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aa80aeab5766416ae37b0c550a756fcf5">soap_wsrm_seq_insert_ack</a> (struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:aa80aeab5766416ae37b0c550a756fcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to insert acksid for fast lookup.  <a href="#aa80aeab5766416ae37b0c550a756fcf5"></a><br/></td></tr>
<tr class="separator:aa80aeab5766416ae37b0c550a756fcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bf1a5470fbb8fa7d509f17e281214"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#afa7bf1a5470fbb8fa7d509f17e281214">soap_wsrm_seq_delete_ack</a> (struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:afa7bf1a5470fbb8fa7d509f17e281214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to delete acksid for fast lookup.  <a href="#afa7bf1a5470fbb8fa7d509f17e281214"></a><br/></td></tr>
<tr class="separator:afa7bf1a5470fbb8fa7d509f17e281214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3fb99b5475b570e23c421a067894fd"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aab3fb99b5475b570e23c421a067894fd">soap_wsrm_seq_lookup_ack</a> (const char *id)</td></tr>
<tr class="memdesc:aab3fb99b5475b570e23c421a067894fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up sequence given its acksid.  <a href="#aab3fb99b5475b570e23c421a067894fd"></a><br/></td></tr>
<tr class="separator:aab3fb99b5475b570e23c421a067894fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b520de586361ecfed29c08d60c4c08"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aa4b520de586361ecfed29c08d60c4c08">soap_wsrm_seq_insert</a> (struct soap *soap)</td></tr>
<tr class="memdesc:aa4b520de586361ecfed29c08d60c4c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to create a new local sequence state.  <a href="#aa4b520de586361ecfed29c08d60c4c08"></a><br/></td></tr>
<tr class="separator:aa4b520de586361ecfed29c08d60c4c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a66b74f5a83ccd622d21761eee2cd8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ab9a66b74f5a83ccd622d21761eee2cd8">soap_wsrm_msg_append</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *data, const char *buf, size_t len)</td></tr>
<tr class="memdesc:ab9a66b74f5a83ccd622d21761eee2cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used by <a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac" title="Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to...">soap_wsrm_send()</a> to append message data to the current message being transmitted in the current sequence.  <a href="#ab9a66b74f5a83ccd622d21761eee2cd8"></a><br/></td></tr>
<tr class="separator:ab9a66b74f5a83ccd622d21761eee2cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f6112c6e361533f7b6443baae09578"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a65f6112c6e361533f7b6443baae09578">soap_wsrm_num_lookup</a> (struct soap *soap, const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr class="memdesc:a65f6112c6e361533f7b6443baae09578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to look up a message number in the sequence state.  <a href="#a65f6112c6e361533f7b6443baae09578"></a><br/></td></tr>
<tr class="separator:a65f6112c6e361533f7b6443baae09578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438af9292fd010392709375126346ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0438af9292fd010392709375126346ca">soap_wsrm_num_insert</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr class="memdesc:a0438af9292fd010392709375126346ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to insert a message number in the sequence state. Updates the sequence ranges.  <a href="#a0438af9292fd010392709375126346ca"></a><br/></td></tr>
<tr class="separator:a0438af9292fd010392709375126346ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae505bc4b6468b034dddc6d5562d5d564"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae505bc4b6468b034dddc6d5562d5d564">soap_wsrm_num_size</a> (const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:ae505bc4b6468b034dddc6d5562d5d564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function returns the number of message ranges of the successfully received messages in a sequence state.  <a href="#ae505bc4b6468b034dddc6d5562d5d564"></a><br/></td></tr>
<tr class="separator:ae505bc4b6468b034dddc6d5562d5d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e11870cb50f0a06b8f3b4bc4cf2ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ab21e11870cb50f0a06b8f3b4bc4cf2ef">soap_wsrm_num_free</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:ab21e11870cb50f0a06b8f3b4bc4cf2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to deallocate all message number ranges from a sequence state.  <a href="#ab21e11870cb50f0a06b8f3b4bc4cf2ef"></a><br/></td></tr>
<tr class="separator:ab21e11870cb50f0a06b8f3b4bc4cf2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259f8b53be93534e90ccc56a46d76c02"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a259f8b53be93534e90ccc56a46d76c02">soap_wsrm_msg_new</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, ULONG64 num)</td></tr>
<tr class="memdesc:a259f8b53be93534e90ccc56a46d76c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to allocate a new message in a sequence, updates message count seq-&gt;num.  <a href="#a259f8b53be93534e90ccc56a46d76c02"></a><br/></td></tr>
<tr class="separator:a259f8b53be93534e90ccc56a46d76c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3f1f0d75b70c9ba5df7ec5935037c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0e3f1f0d75b70c9ba5df7ec5935037c7">soap_wsrm_msg_free</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *p)</td></tr>
<tr class="memdesc:a0e3f1f0d75b70c9ba5df7ec5935037c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to deallocate all cached message content from a sequence state.  <a href="#a0e3f1f0d75b70c9ba5df7ec5935037c7"></a><br/></td></tr>
<tr class="separator:a0e3f1f0d75b70c9ba5df7ec5935037c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1351fd2ece8ddd1a8da40e7ebe6b36f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f">soap_wsrm_create</a> (struct soap *soap, const char *to, const char *replyto, LONG64 expires, const char *wsa_id, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *seq)</td></tr>
<tr class="memdesc:ae1351fd2ece8ddd1a8da40e7ebe6b36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.  <a href="#ae1351fd2ece8ddd1a8da40e7ebe6b36f"></a><br/></td></tr>
<tr class="separator:ae1351fd2ece8ddd1a8da40e7ebe6b36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cb27e4c3139e5197a30d15686cadca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a54cb27e4c3139e5197a30d15686cadca">soap_wsrm_create_offer</a> (struct soap *soap, const char *to, const char *replyto, const char *id, LONG64 expires, enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a> behavior, const char *wsa_id, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *seq)</td></tr>
<tr class="memdesc:a54cb27e4c3139e5197a30d15686cadca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.  <a href="#a54cb27e4c3139e5197a30d15686cadca"></a><br/></td></tr>
<tr class="separator:a54cb27e4c3139e5197a30d15686cadca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5289c0ff322a2a33ebfa18aba1c3647b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a5289c0ff322a2a33ebfa18aba1c3647b">soap_wsrm_create_offer_acksto</a> (struct soap *soap, const char *to, const char *replyto, const char *acksto, const char *id, LONG64 expires, enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a> behavior, const char *wsa_id, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *seq)</td></tr>
<tr class="memdesc:a5289c0ff322a2a33ebfa18aba1c3647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to and an 'acksto' address can be given for acknowledgement messages to be sent to (normally to the reply to). A sequence ID is generated by the server upon success.  <a href="#a5289c0ff322a2a33ebfa18aba1c3647b"></a><br/></td></tr>
<tr class="separator:a5289c0ff322a2a33ebfa18aba1c3647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fdeabdc2ec09fb63b27839275598d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ae5fdeabdc2ec09fb63b27839275598d3">soap_wsrm_request_num</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action, ULONG64 num)</td></tr>
<tr class="memdesc:ae5fdeabdc2ec09fb63b27839275598d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted. No acks are requested.  <a href="#ae5fdeabdc2ec09fb63b27839275598d3"></a><br/></td></tr>
<tr class="separator:ae5fdeabdc2ec09fb63b27839275598d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05857d4bed3b3052e6878f490330277f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a05857d4bed3b3052e6878f490330277f">soap_wsrm_request</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action)</td></tr>
<tr class="memdesc:a05857d4bed3b3052e6878f490330277f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. No acks are requested.  <a href="#a05857d4bed3b3052e6878f490330277f"></a><br/></td></tr>
<tr class="separator:a05857d4bed3b3052e6878f490330277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7292b4a8e24e767b538e0fb2993a6864"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a7292b4a8e24e767b538e0fb2993a6864">soap_wsrm_request_acks</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id, const char *wsa_action)</td></tr>
<tr class="memdesc:a7292b4a8e24e767b538e0fb2993a6864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. Message acks for the current sequence are requested.  <a href="#a7292b4a8e24e767b538e0fb2993a6864"></a><br/></td></tr>
<tr class="separator:a7292b4a8e24e767b538e0fb2993a6864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091a66f982799656bf39cf713ff29eff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a091a66f982799656bf39cf713ff29eff">soap_wsrm_check_retry</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a091a66f982799656bf39cf713ff29eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client-side check to verify if the remote call can be retried when a failure occured. Increases the robustness of messages sends, by ensuring that the message was at least transmitted (but not necessarily received). Also implements HTTP 307 Temporary Redirect. Retries are limited to SOAP_WSRM_MAX_RETRIES iterations.  <a href="#a091a66f982799656bf39cf713ff29eff"></a><br/></td></tr>
<tr class="separator:a091a66f982799656bf39cf713ff29eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0644e93628d1c450cb3c73fed5afd4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af0644e93628d1c450cb3c73fed5afd4f">soap_wsrm_resend</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, ULONG64 lower, ULONG64 upper)</td></tr>
<tr class="memdesc:af0644e93628d1c450cb3c73fed5afd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#abd9ac0c9258d6f2210d767aeff3cbf51" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address (which was set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>, or the ReplyTo address). It is recommended to resend messages after the last message in the sequence was transmitted before closing the sequence. To reduce unnecessary resend attempts, it is recommended to use soap_wsrm_request_ack() with the last message to request acks for messages already delivered.  <a href="#af0644e93628d1c450cb3c73fed5afd4f"></a><br/></td></tr>
<tr class="separator:af0644e93628d1c450cb3c73fed5afd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1d30d3aa050a144da969f0b65b830f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a5b1d30d3aa050a144da969f0b65b830f">soap_wsrm_resend_only_nacked</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, ULONG64 lower, ULONG64 upper)</td></tr>
<tr class="memdesc:a5b1d30d3aa050a144da969f0b65b830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resend all explicitly nack'ed messages indicaed by peer. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#abd9ac0c9258d6f2210d767aeff3cbf51" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address (which was set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>, or the ReplyTo address).  <a href="#a5b1d30d3aa050a144da969f0b65b830f"></a><br/></td></tr>
<tr class="separator:a5b1d30d3aa050a144da969f0b65b830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663e39e46e4fb291ee0f9af8a0badac5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a663e39e46e4fb291ee0f9af8a0badac5">soap_wsrm_close</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id)</td></tr>
<tr class="memdesc:a663e39e46e4fb291ee0f9af8a0badac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a> if desired.  <a href="#a663e39e46e4fb291ee0f9af8a0badac5"></a><br/></td></tr>
<tr class="separator:a663e39e46e4fb291ee0f9af8a0badac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55a951561e63b74699003f423e6e4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aed55a951561e63b74699003f423e6e4d">soap_wsrm_terminate</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id)</td></tr>
<tr class="memdesc:aed55a951561e63b74699003f423e6e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates the sequence. No new messages should be send and no resends should be tried. Usually done after <a class="el" href="wsrmapi_8h.html#a663e39e46e4fb291ee0f9af8a0badac5" title="Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with soap_wsrm_resend() if desired.">soap_wsrm_close()</a> or any time to terminate the sequence prematurely.  <a href="#aed55a951561e63b74699003f423e6e4d"></a><br/></td></tr>
<tr class="separator:aed55a951561e63b74699003f423e6e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb61518a4742df0e441dd100afd73693"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#afb61518a4742df0e441dd100afd73693">soap_wsrm_pulse</a> (struct soap *soap, int timeout)</td></tr>
<tr class="memdesc:afb61518a4742df0e441dd100afd73693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends acknowledgements for all open sessions to all peers. Must set send and recv timeouts to prevent blocking.  <a href="#afb61518a4742df0e441dd100afd73693"></a><br/></td></tr>
<tr class="separator:afb61518a4742df0e441dd100afd73693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc1849fe2ecca83d6a5c95c314ecd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ac3fc1849fe2ecca83d6a5c95c314ecd3">soap_wsrm_acknowledgement</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, const char *wsa_id)</td></tr>
<tr class="memdesc:ac3fc1849fe2ecca83d6a5c95c314ecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends acknowledgements for all message sequences that require an acknowledgement (ack requested by peer)  <a href="#ac3fc1849fe2ecca83d6a5c95c314ecd3"></a><br/></td></tr>
<tr class="separator:ac3fc1849fe2ecca83d6a5c95c314ecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af293ea99286ff93a4319430e94ec3627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af293ea99286ff93a4319430e94ec3627">soap_wsrm_non_acknowledgement</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq, ULONG64 nack)</td></tr>
<tr class="memdesc:af293ea99286ff93a4319430e94ec3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends nack non-acknowledgement for a message.  <a href="#af293ea99286ff93a4319430e94ec3627"></a><br/></td></tr>
<tr class="separator:af293ea99286ff93a4319430e94ec3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c32d0aaadf26d86170098a890c0e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a21c32d0aaadf26d86170098a890c0e54">soap_wsrm_seq_free</a> (struct soap *soap, <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a21c32d0aaadf26d86170098a890c0e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be called to free the sequence allocated by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or by <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>. Sequences created by soap_wsrm_create_offer return handles that are not automatically reclaimed by the engine.  <a href="#a21c32d0aaadf26d86170098a890c0e54"></a><br/></td></tr>
<tr class="separator:a21c32d0aaadf26d86170098a890c0e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af663ecef2b9b1c780a0dc39a1602ab08"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af663ecef2b9b1c780a0dc39a1602ab08">soap_wsrm_to</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:af663ecef2b9b1c780a0dc39a1602ab08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the endpoint address of the destination service that serves the sequence. Initially set with soap_wsrm_create or soap_wsrm_create_offer. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding that can be used to send message to the server endpoint.  <a href="#af663ecef2b9b1c780a0dc39a1602ab08"></a><br/></td></tr>
<tr class="separator:af663ecef2b9b1c780a0dc39a1602ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b95f84a8d4718f3f3ba86592f9c099"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a89b95f84a8d4718f3f3ba86592f9c099">soap_wsrm_acksto</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a89b95f84a8d4718f3f3ba86592f9c099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the endpoint address of the AcksTo acknowledgement service that serves the sequence, when set with <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> or NULL otherwise. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding.  <a href="#a89b95f84a8d4718f3f3ba86592f9c099"></a><br/></td></tr>
<tr class="separator:a89b95f84a8d4718f3f3ba86592f9c099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c22db1671c488e9eef77d5f55b687e7"><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a7c22db1671c488e9eef77d5f55b687e7">soap_wsrm_num</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a7c22db1671c488e9eef77d5f55b687e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current message number of the sequence.  <a href="#a7c22db1671c488e9eef77d5f55b687e7"></a><br/></td></tr>
<tr class="separator:a7c22db1671c488e9eef77d5f55b687e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6aec6d79f12deef6b60e878a7c3dc9"><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a5a6aec6d79f12deef6b60e878a7c3dc9">soap_wsrm_nack</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a5a6aec6d79f12deef6b60e878a7c3dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of non-acknowledged messages sent.  <a href="#a5a6aec6d79f12deef6b60e878a7c3dc9"></a><br/></td></tr>
<tr class="separator:a5a6aec6d79f12deef6b60e878a7c3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0304e1219b99929fa576cf12114206eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a0304e1219b99929fa576cf12114206eb">soap_wsrm_check</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a0304e1219b99929fa576cf12114206eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation. When NoDicards behavior is set, out of sequence messages will be discared until message sequence has resumed (requires peer resends).  <a href="#a0304e1219b99929fa576cf12114206eb"></a><br/></td></tr>
<tr class="separator:a0304e1219b99929fa576cf12114206eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e440bcc087dbd943b30a112f476193"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af8e440bcc087dbd943b30a112f476193">soap_wsrm_check_and_wait</a> (struct soap *soap, int timeout)</td></tr>
<tr class="memdesc:af8e440bcc087dbd943b30a112f476193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation.  <a href="#af8e440bcc087dbd943b30a112f476193"></a><br/></td></tr>
<tr class="separator:af8e440bcc087dbd943b30a112f476193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610fc6b7362861887d5f50c949e12818"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a610fc6b7362861887d5f50c949e12818">soap_wsrm_check_send_empty_response</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a610fc6b7362861887d5f50c949e12818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that sends an empty response back (one-way messaging). The behavior is the same as <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> followed by soap_send_empty_response(), but more efficient and prevents blocking.  <a href="#a610fc6b7362861887d5f50c949e12818"></a><br/></td></tr>
<tr class="separator:a610fc6b7362861887d5f50c949e12818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8641e119a993564112e0a0e4a1000d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a8641e119a993564112e0a0e4a1000d0d">soap_wsrm_check_send_empty_response_and_wait</a> (struct soap *soap, int timeout)</td></tr>
<tr class="memdesc:a8641e119a993564112e0a0e4a1000d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that sends an empty response back (one-way messaging). The behavior is the same as <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> followed by soap_send_empty_response(), but more efficient and prevents blocking.  <a href="#a8641e119a993564112e0a0e4a1000d0d"></a><br/></td></tr>
<tr class="separator:a8641e119a993564112e0a0e4a1000d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12748409763500ea6907ff1225bc5c83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a12748409763500ea6907ff1225bc5c83">soap_wsrm_reply_num</a> (struct soap *soap, int flag)</td></tr>
<tr class="memdesc:a12748409763500ea6907ff1225bc5c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares reply from service. When flag is set, adds a WS-RM sequence message number to the next message transmitted. No acks are requested. No WS-Addressing message relay.  <a href="#a12748409763500ea6907ff1225bc5c83"></a><br/></td></tr>
<tr class="separator:a12748409763500ea6907ff1225bc5c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ab54d15beca0118bdffc64520b6589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af7ab54d15beca0118bdffc64520b6589">soap_wsrm_reply</a> (struct soap *soap, const char *wsa_id, const char *wsa_action)</td></tr>
<tr class="memdesc:af7ab54d15beca0118bdffc64520b6589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and/or allow the response message to be relayed as per WS-Addressing).  <a href="#af7ab54d15beca0118bdffc64520b6589"></a><br/></td></tr>
<tr class="separator:af7ab54d15beca0118bdffc64520b6589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88bd9d375279ec59cbb82ba0e76caf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad88bd9d375279ec59cbb82ba0e76caf2">soap_wsrm_reply_request_acks</a> (struct soap *soap, const char *wsa_id, const char *wsa_action)</td></tr>
<tr class="memdesc:ad88bd9d375279ec59cbb82ba0e76caf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server-side server operation reply to be performed when the service operation returns. Message acks for the current sequence are requested, but only when client made a create sequence offer. Server operations that support WS-Addressing and WS-RM must call this function or call <a class="el" href="wsrmapi_8h.html#af7ab54d15beca0118bdffc64520b6589" title="Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and/or allow the response message to be relayed as per WS-Addressing).">soap_wsrm_reply()</a> to return normally (and/or allow the response message to be relayed as per WS-Addressing).  <a href="#ad88bd9d375279ec59cbb82ba0e76caf2"></a><br/></td></tr>
<tr class="separator:ad88bd9d375279ec59cbb82ba0e76caf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16c06bd2a4cb938c1c66868b34d4b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1b16c06bd2a4cb938c1c66868b34d4b5">soap_wsrm_cleanup</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a1b16c06bd2a4cb938c1c66868b34d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all expired sequences and releases resources. To be used at the server side to periodically clean up WS-RM sequences. Server-side cleanup is automatic, as long as WS-RM is in use. Does not release client-side sequences allocated by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>.  <a href="#a1b16c06bd2a4cb938c1c66868b34d4b5"></a><br/></td></tr>
<tr class="separator:a1b16c06bd2a4cb938c1c66868b34d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3adfdfdc6c60dd2085f3adb541f7c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#afc3adfdfdc6c60dd2085f3adb541f7c3">__wsrm__CreateSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____create_sequence_type.html">wsrm__CreateSequenceType</a> *req, struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:afc3adfdfdc6c60dd2085f3adb541f7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CreateSequence service operation. Automatically invoked by the server to process a create sequence request (with or without offer). Creates a new local sequence state to keep track of messages.  <a href="#afc3adfdfdc6c60dd2085f3adb541f7c3"></a><br/></td></tr>
<tr class="separator:afc3adfdfdc6c60dd2085f3adb541f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7298a311f1c3574d5f7c5cd64fb15d10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a7298a311f1c3574d5f7c5cd64fb15d10">__wsrm__CreateSequenceResponse</a> (struct soap *soap, struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:a7298a311f1c3574d5f7c5cd64fb15d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CreateSequenceResponse one-way service operation. Automatically invoked by the server to process a create sequence response (with or without offer). Creates a new local sequence state to keep track of messages.  <a href="#a7298a311f1c3574d5f7c5cd64fb15d10"></a><br/></td></tr>
<tr class="separator:a7298a311f1c3574d5f7c5cd64fb15d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45392a369c8c0c545a8356958ffe8638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a45392a369c8c0c545a8356958ffe8638">__wsrm__CloseSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____close_sequence_type.html">wsrm__CloseSequenceType</a> *req, struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:a45392a369c8c0c545a8356958ffe8638"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CloseSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to closed.  <a href="#a45392a369c8c0c545a8356958ffe8638"></a><br/></td></tr>
<tr class="separator:a45392a369c8c0c545a8356958ffe8638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72df090268eeb72e955abca12e44eae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a72df090268eeb72e955abca12e44eae5">__wsrm__CloseSequenceResponse</a> (struct soap *soap, struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:a72df090268eeb72e955abca12e44eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM CloseSequenceResponse one-way service operation. Automatically invoked by the server to process the close sequence response. Updates the server's local sequence state to closed.  <a href="#a72df090268eeb72e955abca12e44eae5"></a><br/></td></tr>
<tr class="separator:a72df090268eeb72e955abca12e44eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad937d441ba6e8fe06b7c4b2d958512bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad937d441ba6e8fe06b7c4b2d958512bb">__wsrm__TerminateSequence</a> (struct soap *soap, struct <a class="el" href="structwsrm_____terminate_sequence_type.html">wsrm__TerminateSequenceType</a> *req, struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:ad937d441ba6e8fe06b7c4b2d958512bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM TerminateSequence service operation. Automatically invoked by the server to process the terminate sequence request. Updates the server's local sequence state to terminated.  <a href="#ad937d441ba6e8fe06b7c4b2d958512bb"></a><br/></td></tr>
<tr class="separator:ad937d441ba6e8fe06b7c4b2d958512bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc329328d435539c15c56a011744a54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a5bc329328d435539c15c56a011744a54">__wsrm__TerminateSequenceResponse</a> (struct soap *soap, struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *res)</td></tr>
<tr class="memdesc:a5bc329328d435539c15c56a011744a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM TerminateSequenceResponse one-way service operation. Automatically invoked by the server to process the terminate sequence response. Updates the server's local sequence state to terminated.  <a href="#a5bc329328d435539c15c56a011744a54"></a><br/></td></tr>
<tr class="separator:a5bc329328d435539c15c56a011744a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946176cad5228da0fdbc3b672535e054"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a946176cad5228da0fdbc3b672535e054">__wsrm__SequenceAcknowledgement</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a946176cad5228da0fdbc3b672535e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM SequenceAcknowledgement operation.  <a href="#a946176cad5228da0fdbc3b672535e054"></a><br/></td></tr>
<tr class="separator:a946176cad5228da0fdbc3b672535e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf5dadf742182a542eeceea37486732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a3cf5dadf742182a542eeceea37486732">__wsrm__AckRequested</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a3cf5dadf742182a542eeceea37486732"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM AckRequested operation.  <a href="#a3cf5dadf742182a542eeceea37486732"></a><br/></td></tr>
<tr class="separator:a3cf5dadf742182a542eeceea37486732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a23667f653803002e67d095a37670"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a9e3a23667f653803002e67d095a37670">__wsrm__LastMessage</a> (struct soap *soap)</td></tr>
<tr class="memdesc:a9e3a23667f653803002e67d095a37670"><td class="mdescLeft">&#160;</td><td class="mdescRight">WS-RM LastMessage operation (WS-RM 1.0).  <a href="#a9e3a23667f653803002e67d095a37670"></a><br/></td></tr>
<tr class="separator:a9e3a23667f653803002e67d095a37670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf7a38c3091d9e2f0151009d4bad14b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#addf7a38c3091d9e2f0151009d4bad14b">soap_wsrm_fault_subcode</a> (struct soap *soap, int flag, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr class="memdesc:addf7a38c3091d9e2f0151009d4bad14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender/receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#addf7a38c3091d9e2f0151009d4bad14b"></a><br/></td></tr>
<tr class="separator:addf7a38c3091d9e2f0151009d4bad14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a53920fbe164b32905a34a73317ac6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a94a53920fbe164b32905a34a73317ac6">soap_wsrm_sender_fault_subcode</a> (struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr class="memdesc:a94a53920fbe164b32905a34a73317ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a94a53920fbe164b32905a34a73317ac6"></a><br/></td></tr>
<tr class="separator:a94a53920fbe164b32905a34a73317ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb3621b4a3ab658059000974d7ee96c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a6cb3621b4a3ab658059000974d7ee96c">soap_wsrm_receiver_fault_subcode</a> (struct soap *soap, const char *faultsubcode, const char *faultstring, const char *faultdetail)</td></tr>
<tr class="memdesc:a6cb3621b4a3ab658059000974d7ee96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a6cb3621b4a3ab658059000974d7ee96c"></a><br/></td></tr>
<tr class="separator:a6cb3621b4a3ab658059000974d7ee96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bcd68f3810d632bef61ecfe86e1e5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#af2bcd68f3810d632bef61ecfe86e1e5f">soap_wsrm_sender_fault</a> (struct soap *soap, const char *faultstring, const char *faultdetail)</td></tr>
<tr class="memdesc:af2bcd68f3810d632bef61ecfe86e1e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sender SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#af2bcd68f3810d632bef61ecfe86e1e5f"></a><br/></td></tr>
<tr class="separator:af2bcd68f3810d632bef61ecfe86e1e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c7a86eaf7366b9cb9c4759c1f7c061"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a65c7a86eaf7366b9cb9c4759c1f7c061">soap_wsrm_receiver_fault</a> (struct soap *soap, const char *faultstring, const char *faultdetail)</td></tr>
<tr class="memdesc:a65c7a86eaf7366b9cb9c4759c1f7c061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender.  <a href="#a65c7a86eaf7366b9cb9c4759c1f7c061"></a><br/></td></tr>
<tr class="separator:a65c7a86eaf7366b9cb9c4759c1f7c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bfb3df2145cb5a7302129dfedd2645"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a27bfb3df2145cb5a7302129dfedd2645">soap_wsrm_check_fault</a> (struct soap *soap, enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> *fault, const char **info)</td></tr>
<tr class="memdesc:a27bfb3df2145cb5a7302129dfedd2645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the presence of a WS-RM fault at the client side (or in the FaultTo destination service) when a response is received.  <a href="#a27bfb3df2145cb5a7302129dfedd2645"></a><br/></td></tr>
<tr class="separator:a27bfb3df2145cb5a7302129dfedd2645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2c3d3298b9695483f5562d9765e8cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a8c2c3d3298b9695483f5562d9765e8cc">soap_wsrm_error</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq, enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> fault)</td></tr>
<tr class="memdesc:a8c2c3d3298b9695483f5562d9765e8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets SOAP Fault (sub)code for server WS-RM fault response. Terminates the sequence.  <a href="#a8c2c3d3298b9695483f5562d9765e8cc"></a><br/></td></tr>
<tr class="separator:a8c2c3d3298b9695483f5562d9765e8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b52421482f2afaf2bd44cf1372c91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a283b52421482f2afaf2bd44cf1372c91">soap_wsrm_dump</a> (struct soap *soap, FILE *fd)</td></tr>
<tr class="memdesc:a283b52421482f2afaf2bd44cf1372c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the current sequences and details of the wsrm plugin for diagnotics purposes.  <a href="#a283b52421482f2afaf2bd44cf1372c91"></a><br/></td></tr>
<tr class="separator:a283b52421482f2afaf2bd44cf1372c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf792b8e8eff0209f4d84e156d726231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aaf792b8e8eff0209f4d84e156d726231">soap_wsrm</a> (struct soap *soap, struct soap_plugin *p, void *arg)</td></tr>
<tr class="memdesc:aaf792b8e8eff0209f4d84e156d726231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plugin registry function, used with soap_register_plugin.  <a href="#aaf792b8e8eff0209f4d84e156d726231"></a><br/></td></tr>
<tr class="separator:aaf792b8e8eff0209f4d84e156d726231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf30da78ce8219490ae6bf3419261c5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a4cf30da78ce8219490ae6bf3419261c5">soap_wsrm_seq_lookup_id</a> (struct soap *soap, const char *id)</td></tr>
<tr class="memdesc:a4cf30da78ce8219490ae6bf3419261c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to look up sequence given its id.  <a href="#a4cf30da78ce8219490ae6bf3419261c5"></a><br/></td></tr>
<tr class="separator:a4cf30da78ce8219490ae6bf3419261c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3ba7e98b20cc44d969e6c673c92a8a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a4c3ba7e98b20cc44d969e6c673c92a8a">soap_wsrm_seq_lookup</a> (struct soap *soap, const char *id)</td></tr>
<tr class="memdesc:a4c3ba7e98b20cc44d969e6c673c92a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to look up sequence given its id.  <a href="#a4c3ba7e98b20cc44d969e6c673c92a8a"></a><br/></td></tr>
<tr class="separator:a4c3ba7e98b20cc44d969e6c673c92a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7ce54ffe117f054f2e4f0401965b24"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aaf7ce54ffe117f054f2e4f0401965b24">soap_wsrm_seq</a> (struct soap *soap)</td></tr>
<tr class="memdesc:aaf7ce54ffe117f054f2e4f0401965b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming a SOAP header is received, gets the sequence associated with the message.  <a href="#aaf7ce54ffe117f054f2e4f0401965b24"></a><br/></td></tr>
<tr class="separator:aaf7ce54ffe117f054f2e4f0401965b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9340a192f64193f17e03666792016c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a9340a192f64193f17e03666792016c63">soap_wsrm_seq_release</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:a9340a192f64193f17e03666792016c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases handle.  <a href="#a9340a192f64193f17e03666792016c63"></a><br/></td></tr>
<tr class="separator:a9340a192f64193f17e03666792016c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902ad24f3be482a11208b81ccb25c21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#ad902ad24f3be482a11208b81ccb25c21">soap_wsrm_seq_created</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:ad902ad24f3be482a11208b81ccb25c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a sequence is created.  <a href="#ad902ad24f3be482a11208b81ccb25c21"></a><br/></td></tr>
<tr class="separator:ad902ad24f3be482a11208b81ccb25c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4da9c5b03f165594e2d3d60dacbdd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aff4da9c5b03f165594e2d3d60dacbdd9">soap_wsrm_seq_valid</a> (struct soap *soap, struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *seq)</td></tr>
<tr class="memdesc:aff4da9c5b03f165594e2d3d60dacbdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if a sequence is not valid, terminated, or needs to be terminated when expired.  <a href="#aff4da9c5b03f165594e2d3d60dacbdd9"></a><br/></td></tr>
<tr class="separator:aff4da9c5b03f165594e2d3d60dacbdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedd64475f8207a34c8860e2e0ebb4f"><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1bedd64475f8207a34c8860e2e0ebb4f">soap_wsrm_msgs</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:a1bedd64475f8207a34c8860e2e0ebb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of complete messages received, or 0 when there is a gap.  <a href="#a1bedd64475f8207a34c8860e2e0ebb4f"></a><br/></td></tr>
<tr class="separator:a1bedd64475f8207a34c8860e2e0ebb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf043461c8e4e763adeed287442a7123"><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#adf043461c8e4e763adeed287442a7123">soap_wsrm_recvnum</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:adf043461c8e4e763adeed287442a7123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message number of last message received.  <a href="#adf043461c8e4e763adeed287442a7123"></a><br/></td></tr>
<tr class="separator:adf043461c8e4e763adeed287442a7123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8456f4f9277bfebac9a03c41038d4a6"><td class="memItemLeft" align="right" valign="top">ULONG64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#aa8456f4f9277bfebac9a03c41038d4a6">soap_wsrm_lastnum</a> (const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> seq)</td></tr>
<tr class="memdesc:aa8456f4f9277bfebac9a03c41038d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last message number upon sequence close or 0.  <a href="#aa8456f4f9277bfebac9a03c41038d4a6"></a><br/></td></tr>
<tr class="separator:aa8456f4f9277bfebac9a03c41038d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16749a18a895060a7ad09c96fc9744bd"><td class="memItemLeft" align="right" valign="top">static unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a16749a18a895060a7ad09c96fc9744bd">soap_wsrm_msb</a> (register ULONG64 n)</td></tr>
<tr class="separator:a16749a18a895060a7ad09c96fc9744bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2f5b88f6da2708c658e230610ca380ab"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a2f5b88f6da2708c658e230610ca380ab">soap_wsrm_id</a> [] = <a class="el" href="wsrmapi_8h.html#a0578c988308fdba3053e1aee6885e94d">SOAP_WSRM_ID</a></td></tr>
<tr class="separator:a2f5b88f6da2708c658e230610ca380ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b87a809162eab1f088457a69765dfa6"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1b87a809162eab1f088457a69765dfa6">soap_wsrm_session</a> = NULL</td></tr>
<tr class="separator:a1b87a809162eab1f088457a69765dfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b413c93faa278f185f742ee8d1da4c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a64b413c93faa278f185f742ee8d1da4c">soap_wsrm_idname</a> [40] = &quot;&quot;</td></tr>
<tr class="separator:a64b413c93faa278f185f742ee8d1da4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b7ed420cfa320543882a34238f55b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a29b7ed420cfa320543882a34238f55b8">soap_wsrm_idnum</a> = 0</td></tr>
<tr class="separator:a29b7ed420cfa320543882a34238f55b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f675d133185cc7a40b0af8e0d5ffdcb"><td class="memItemLeft" align="right" valign="top">static MUTEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wsrmapi_8c.html#a1f675d133185cc7a40b0af8e0d5ffdcb">soap_wsrm_session_lock</a> = MUTEX_INITIALIZER</td></tr>
<tr class="separator:a1f675d133185cc7a40b0af8e0d5ffdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3cf5dadf742182a542eeceea37486732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__AckRequested </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM AckRequested operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a45392a369c8c0c545a8356958ffe8638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CloseSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____close_sequence_type.html">wsrm__CloseSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM CloseSequence service operation. Automatically invoked by the server to process the close sequence request. Updates the server's local sequence state to closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__CloseSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__CloseSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a72df090268eeb72e955abca12e44eae5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CloseSequenceResponse </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____close_sequence_response_type.html">wsrm__CloseSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM CloseSequenceResponse one-way service operation. Automatically invoked by the server to process the close sequence response. Updates the server's local sequence state to closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>wsrm__CloseSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="afc3adfdfdc6c60dd2085f3adb541f7c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CreateSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____create_sequence_type.html">wsrm__CreateSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM CreateSequence service operation. Automatically invoked by the server to process a create sequence request (with or without offer). Creates a new local sequence state to keep track of messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__CreateSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__CreateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a7298a311f1c3574d5f7c5cd64fb15d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__CreateSequenceResponse </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____create_sequence_response_type.html">wsrm__CreateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM CreateSequenceResponse one-way service operation. Automatically invoked by the server to process a create sequence response (with or without offer). Creates a new local sequence state to keep track of messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>wsrm__CreateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a9e3a23667f653803002e67d095a37670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__LastMessage </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM LastMessage operation (WS-RM 1.0). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a946176cad5228da0fdbc3b672535e054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__SequenceAcknowledgement </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM SequenceAcknowledgement operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ad937d441ba6e8fe06b7c4b2d958512bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__TerminateSequence </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____terminate_sequence_type.html">wsrm__TerminateSequenceType</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM TerminateSequence service operation. Automatically invoked by the server to process the terminate sequence request. Updates the server's local sequence state to terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>wsrm__TerminateSequence request message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>wsrm__TerminateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a5bc329328d435539c15c56a011744a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __wsrm__TerminateSequenceResponse </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structwsrm_____terminate_sequence_response_type.html">wsrm__TerminateSequenceResponseType</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WS-RM TerminateSequenceResponse one-way service operation. Automatically invoked by the server to process the terminate sequence response. Updates the server's local sequence state to terminated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>wsrm__TerminateSequenceResponse response message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="aaf792b8e8eff0209f4d84e156d726231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plugin registry function, used with soap_register_plugin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>plugin created in registry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional argument passed from soap_register_plugin_arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="ac3fc1849fe2ecca83d6a5c95c314ecd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_acknowledgement </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends acknowledgements for all message sequences that require an acknowledgement (ack requested by peer) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (deprecated, not used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a89b95f84a8d4718f3f3ba86592f9c099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap_wsrm_acksto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the endpoint address of the AcksTo acknowledgement service that serves the sequence, when set with <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> or NULL otherwise. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<a class="anchor" id="aea7a9a67116baef61a5788136e809c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_add_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>nack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>piggy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to add SequenceAcknowledgement headers for AckRequested. When piggy==0 or internal AcksTo destination is set, sends acknowledgements to the AcksTo destination service or back to the source related to the seq. These sends can take time, which can be controlled with the soap context connect_timeout, send_timeout, recv_timeout settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nack</td><td>num of nack message, 0 to generate acks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>when true always include all acks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">piggy</td><td>when true add acks to message to be send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a0304e1219b99929fa576cf12114206eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation. When NoDicards behavior is set, out of sequence messages will be discared until message sequence has resumed (requires peer resends). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or SOAP_STOP (duplicate message error, MUST be returned by the service operation executing the soap_wsrm_check) or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="af8e440bcc087dbd943b30a112f476193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_and_wait </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">timeout</td><td>NoDiscard behavior: 0=discard messages out of sequence to immediately resume, &gt;0 wait (in seconds) until message sequence has resumed while sending Nacks every second to indicate messages are required to continue the flow of messages, &lt;0 wait (in microseconds) until message sequence has resumed, send one nack when timeout occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or SOAP_STOP (duplicate message error, MUST be returned by the service operation executing the soap_wsrm_check) or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a27bfb3df2145cb5a7302129dfedd2645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a> *&#160;</td>
          <td class="paramname"><em>fault</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the presence of a WS-RM fault at the client side (or in the FaultTo destination service) when a response is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fault</td><td>code </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>string pointer related to the fault (or NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK (no fault or not a WS-RM fault) or error when not WS-RM fault </dd></dl>

</div>
</div>
<a class="anchor" id="a091a66f982799656bf39cf713ff29eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_retry </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Client-side check to verify if the remote call can be retried when a failure occured. Increases the robustness of messages sends, by ensuring that the message was at least transmitted (but not necessarily received). Also implements HTTP 307 Temporary Redirect. Retries are limited to SOAP_WSRM_MAX_RETRIES iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK when retry is safe, error code otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a610fc6b7362861887d5f50c949e12818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_send_empty_response </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that sends an empty response back (one-way messaging). The behavior is the same as <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> followed by soap_send_empty_response(), but more efficient and prevents blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or SOAP_STOP (duplicate message error, MUST be returned by the service operation executing the soap_wsrm_check) or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a8641e119a993564112e0a0e4a1000d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_check_send_empty_response_and_wait </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that sends an empty response back (one-way messaging). The behavior is the same as <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> followed by soap_send_empty_response(), but more efficient and prevents blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">timeout</td><td>NoDiscard behavior: 0=discard messages out of sequence to immediately resume, &gt;0 wait (in seconds) until message sequence has resumed while sending Nacks every second to indicate messages are required to continue the flow of messages, &lt;0 wait (in microseconds) until message sequence has resumed, send one nack when timeout occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or SOAP_STOP (duplicate message error, MUST be returned by the service operation executing the soap_wsrm_check) or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac701708d0b08b663567391421d26501e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_chk </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP header, checks for protocol errors, and rejects duplicate messages. Also prepares the return WS-RM header. This function should be called in the each service operation that supports WS-RM. Do not use this function in a ReplyTo response-accepting destination service operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">timeout</td><td>NoDiscard behavior: 0=discard messages out of sequence to immediately resume, &gt;0 wait (in seconds) until message sequence has resumed while sending Nacks every second to indicate messages are required to continue the flow of messages, &lt;0 wait (in microseconds) until message sequence has resumed, send one nack when timeout occurred. </td></tr>
    <tr><td class="paramname">flag</td><td>0=no response, 1=send empty response </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or SOAP_STOP (duplicate message error, MUST be returned by the service operation executing the soap_wsrm_check) or an error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aed2eeaf0ead74ae222d5d9eee78c3ed6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_chk_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to check for AckRequested headers to update state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a1b16c06bd2a4cb938c1c66868b34d4b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up all expired sequences and releases resources. To be used at the server side to periodically clean up WS-RM sequences. Server-side cleanup is automatic, as long as WS-RM is in use. Does not release client-side sequences allocated by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a663e39e46e4fb291ee0f9af8a0badac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_close </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a> if desired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a4f296f96d8787a1f864a5d3562250f0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_copy </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy plugin data (private thread data). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="ae1351fd2ece8ddd1a8da40e7ebe6b36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_create </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>replyto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG64&#160;</td>
          <td class="paramname"><em>expires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>endpoint address of the WS-RM destination server (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replyto</td><td>endpoint address of the WS-RM source to reply/ack to (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expires</td><td>max sequence duration (its lifetime) in ms (use 0 to offer infinite, subject to server policy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seq</td><td>sequence handle is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a54cb27e4c3139e5197a30d15686cadca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_create_offer </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>replyto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG64&#160;</td>
          <td class="paramname"><em>expires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a>&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>endpoint address of the WS-RM destination server (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replyto</td><td>endpoint address of the WS-RM source to reply/ack to (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>offered WS-RM sequence identifier (optional, generate with NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expires</td><td>max sequence duration (its lifetime) in ms (use 0 for infinite, subject to server policy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>offered DiscardEntireSequence, DiscardFollowingFirstGap, or NoDiscard, which specifies the WS-RM destination's action when a sequence is closed/terminated when it is incomplete, and notifies the source when failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seq</td><td>sequence handle is set or NULL when response is asynchronously send and the sequence is initialized upon receipt of the create response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a5289c0ff322a2a33ebfa18aba1c3647b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_create_offer_acksto </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>replyto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>acksto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG64&#160;</td>
          <td class="paramname"><em>expires</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#aff9cd7eafbe766f7c92b26f868cb0418">wsrm__IncompleteSequenceBehaviorType</a>&#160;</td>
          <td class="paramname"><em>behavior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The 'to' server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the 'replyto' address can be given of the WS-RM source to reply to and an 'acksto' address can be given for acknowledgement messages to be sent to (normally to the reply to). A sequence ID is generated by the server upon success. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>endpoint address of the WS-RM destination server (required) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replyto</td><td>endpoint address of the WS-RM source (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">acksto</td><td>endpoint address for WS-RM acknowledgements (optional) (optional, use NULL when acks are piggy-backed on response messages to the source) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>offered WS-RM sequence identifier (optional, generate when NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expires</td><td>max sequence duration (its lifetime) in ms (use 0 for infinite, subject to server policy) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behavior</td><td>offered DiscardEntireSequence, DiscardFollowingFirstGap, or NoDiscard, which specifies the WS-RM destination's action when a sequence is closed/terminated when it is incomplete, and notifies the source when failed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seq</td><td>sequence handle is set or NULL when response is asynchronously send and the sequence is initialized upon receipt of the create response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="adfeafbbe659550e4055c3f49aa564f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_delete </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct soap_plugin *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes plugin data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>plugin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="a37b48a2e189b15b873083802cafa745a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal callback function to override fdisconnect(). Turns caching off, sets the cached message to NACK, and resets the server-side handle, so sequence can be deallocated later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a283b52421482f2afaf2bd44cf1372c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_dump </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the current sequences and details of the wsrm plugin for diagnotics purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to send text to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c2c3d3298b9695483f5562d9765e8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_error </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="wsrm_8h.html#a74a1b26ed97040d29fb3ad5b1e88a3c8">wsrm__FaultCodes</a>&#160;</td>
          <td class="paramname"><em>fault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets SOAP Fault (sub)code for server WS-RM fault response. Terminates the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence to terminate or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fault</td><td>is one of enum wsrm__FaultCodes enumeration values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="addf7a38c3091d9e2f0151009d4bad14b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sender/receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>0=receiver, 1=sender </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="ae217764567f04ef0b1e2a208f8e62d66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_init </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes plugin data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>plugin data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional argument passed from soap_register_plugin_arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK </dd></dl>

</div>
</div>
<a class="anchor" id="aa8456f4f9277bfebac9a03c41038d4a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_lastnum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last message number upon sequence close or 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last message number or 0 when more messages should be received </dd></dl>

</div>
</div>
<a class="anchor" id="a16749a18a895060a7ad09c96fc9744bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned short soap_wsrm_msb </td>
          <td>(</td>
          <td class="paramtype">register ULONG64&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9a66b74f5a83ccd622d21761eee2cd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_msg_append </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__data.html">soap_wsrm_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function used by <a class="el" href="wsrmapi_8c.html#ac7ff6d902d415e409bd46096022e1eac" title="Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to...">soap_wsrm_send()</a> to append message data to the current message being transmitted in the current sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>message data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a0e3f1f0d75b70c9ba5df7ec5935037c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_msg_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to deallocate all cached message content from a sequence state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">p</td><td>pointer to message (in a sequence state) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a259f8b53be93534e90ccc56a46d76c02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__message.html">soap_wsrm_message</a> * soap_wsrm_msg_new </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to allocate a new message in a sequence, updates message count seq-&gt;num. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence pointer </td></tr>
    <tr><td class="paramname">num</td><td>message num (produces error when zero) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to message struct or NULL when error </dd></dl>

</div>
</div>
<a class="anchor" id="a1bedd64475f8207a34c8860e2e0ebb4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_msgs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of complete messages received, or 0 when there is a gap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of messages received or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6aec6d79f12deef6b60e878a7c3dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_nack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of non-acknowledged messages sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of non-acknowledged messages sent </dd></dl>

</div>
</div>
<a class="anchor" id="af293ea99286ff93a4319430e94ec3627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_non_acknowledgement </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>nack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends nack non-acknowledgement for a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramname">nack</td><td>num of message to nack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a7c22db1671c488e9eef77d5f55b687e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current message number of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence endpoint address </dd></dl>

</div>
</div>
<a class="anchor" id="ab21e11870cb50f0a06b8f3b4bc4cf2ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_num_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to deallocate all message number ranges from a sequence state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0438af9292fd010392709375126346ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_insert </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to insert a message number in the sequence state. Updates the sequence ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (out of memory) </dd></dl>

</div>
</div>
<a class="anchor" id="a65f6112c6e361533f7b6443baae09578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_lookup </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to look up a message number in the sequence state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>message num to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (not found) 1 (found) </dd></dl>

</div>
</div>
<a class="anchor" id="ae505bc4b6468b034dddc6d5562d5d564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_num_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function returns the number of message ranges of the successfully received messages in a sequence state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of message ranges </dd></dl>

</div>
</div>
<a class="anchor" id="aaff41127e3a1960010dd0eed252a1779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_preparefinalrecv </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal callback function to override fpreparefinalrecv(). Takes acks returned by response to update the states of the sequences with acknowledgements. Acknowledged messages do not have to be resend and are purged from the sequence states. Also checks if at client-side response message was already received and otherwise records it in the state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a3a1093d90de46a3170cfc9d980c728a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_process_ack </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to purge acknowledged messages as given by wsrm:SequenceAcknowledgement header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ack</td><td>from the WS-RM SequenceAcknowledgement header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="afb61518a4742df0e441dd100afd73693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_pulse </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends acknowledgements for all open sessions to all peers. Must set send and recv timeouts to prevent blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">timeout</td><td>seconds (positive value) or microseconds (negative value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or an error code when one or more peers fault (the last error code is returned) </dd></dl>

</div>
</div>
<a class="anchor" id="a65c7a86eaf7366b9cb9c4759c1f7c061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_receiver_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets receiver SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb3621b4a3ab658059000974d7ee96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_receiver_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets receiver SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="adf043461c8e4e763adeed287442a7123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG64 soap_wsrm_recvnum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the message number of last message received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>message number of last message received </dd></dl>

</div>
</div>
<a class="anchor" id="af7ab54d15beca0118bdffc64520b6589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and/or allow the response message to be relayed as per WS-Addressing). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the response </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="a12748409763500ea6907ff1225bc5c83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply_num </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares reply from service. When flag is set, adds a WS-RM sequence message number to the next message transmitted. No acks are requested. No WS-Addressing message relay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">flag</td><td>true to add a WS-RM sequence message number to the message to be transmitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="ad88bd9d375279ec59cbb82ba0e76caf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_reply_request_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Server-side server operation reply to be performed when the service operation returns. Message acks for the current sequence are requested, but only when client made a create sequence offer. Server operations that support WS-Addressing and WS-RM must call this function or call <a class="el" href="wsrmapi_8h.html#af7ab54d15beca0118bdffc64520b6589" title="Server-side server operation reply to be performed when the service operation returns. Server operations that support WS-Addressing and WS-RM must call this function to return normally (and/or allow the response message to be relayed as per WS-Addressing).">soap_wsrm_reply()</a> to return normally (and/or allow the response message to be relayed as per WS-Addressing). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the response </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (and server operation must return this value) </dd></dl>

</div>
</div>
<a class="anchor" id="a05857d4bed3b3052e6878f490330277f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. No acks are requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="a7292b4a8e24e767b538e0fb2993a6864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request_acks </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted to the WS-RM destination and increments the message counter by one. Message acks for the current sequence are requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ae5fdeabdc2ec09fb63b27839275598d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_request_num </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a WS-RM sequence message number to the next message transmitted. No acks are requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional, use NULL when omitted) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_action</td><td>mandatory WS-Addressing action of the next message sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>WS-RM sequence message number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="af0644e93628d1c450cb3c73fed5afd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_resend </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#abd9ac0c9258d6f2210d767aeff3cbf51" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address (which was set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>, or the ReplyTo address). It is recommended to resend messages after the last message in the sequence was transmitted before closing the sequence. To reduce unnecessary resend attempts, it is recommended to use soap_wsrm_request_ack() with the last message to request acks for messages already delivered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>resend message range lower bound (0 for lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>resend message range upper bound (or 0 for infinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (can be ignored when resends are retried later) </dd></dl>

</div>
</div>
<a class="anchor" id="a5b1d30d3aa050a144da969f0b65b830f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_resend_only_nacked </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resend all explicitly nack'ed messages indicaed by peer. Messages stored in the sequence for retransmission (those that were previously sent but not acknowledged) are resent to the <a class="el" href="wsrmapi_8h.html#abd9ac0c9258d6f2210d767aeff3cbf51" title="Returns the endpoint address of the destination service that serves the sequence. Initially set with ...">soap_wsrm_to()</a> address (which was set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>, or the ReplyTo address). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>resend message range lower bound (0 for lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>resend message range upper bound (or 0 for infinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (can be ignored when resends are retried later) </dd></dl>

</div>
</div>
<a class="anchor" id="aae8c5cce68cb47b274c3ddb185d7ffb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_resend_seq </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to resend unacknowledged messages of a sequence given a range of message numbers. Used by <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">all</td><td>1= resend all unacknowledged messages (not just the nacked messages) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>resend message range lower bound (0 for lowest) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>resend message range upper bound (or 0 for infinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code (can be ignored to continue sequence) </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ff6d902d415e409bd46096022e1eac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_send </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal callback function to override fsend(). When the wsrm plugin is enabled, saves the message to the current sequence that is created at the client side. Allows unacknowledged messages to be resend with <a class="el" href="wsrmapi_8h.html#af0644e93628d1c450cb3c73fed5afd4f" title="Resend all unacknowledged messages, i.e. messages that were automatically cached for this sequence...">soap_wsrm_resend()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>message data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>message data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="af2bcd68f3810d632bef61ecfe86e1e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_sender_fault </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sender SOAP Fault for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="a94a53920fbe164b32905a34a73317ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_sender_fault_subcode </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultsubcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>faultdetail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sender SOAP Fault (sub)code for server faults (can be user defined faults). When called before <a class="el" href="wsrmapi_8h.html#a0304e1219b99929fa576cf12114206eb" title="Receiver (server)-side check for the presence of WS-Addressing and WS-RM header blocks in the SOAP he...">soap_wsrm_check()</a> in the server operation, terminates the current sequence. Otherwise, the sequence is not terminated. In either case the fault is returned to sender (client) or to the FaultTo server when the WS-Addressing FaultTo header was set by the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultsubcode</td><td>sub code string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultstring</td><td>fault string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faultdetail</td><td>detail string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_FAULT </dd></dl>

</div>
</div>
<a class="anchor" id="aaf7ce54ffe117f054f2e4f0401965b24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a>* soap_wsrm_seq </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming a SOAP header is received, gets the sequence associated with the message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence handle, must be released with <a class="el" href="wsrmapi_8c.html#a9340a192f64193f17e03666792016c63">soap_wsrm_seq_release</a> when no longer used </dd></dl>

</div>
</div>
<a class="anchor" id="ad902ad24f3be482a11208b81ccb25c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_seq_created </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if a sequence is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (not created) or 1 (created) </dd></dl>

</div>
</div>
<a class="anchor" id="afa7bf1a5470fbb8fa7d509f17e281214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_seq_delete_ack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to delete acksid for fast lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c55c813b637be30e1af3f188d1798d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_seq_delete_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to delete seq id from hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21c32d0aaadf26d86170098a890c0e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_seq_free </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be called to free the sequence allocated by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or by <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a>. Sequences created by soap_wsrm_create_offer return handles that are not automatically reclaimed by the engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4b520de586361ecfed29c08d60c4c08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_insert </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to create a new local sequence state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="aa80aeab5766416ae37b0c550a756fcf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_seq_insert_ack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to insert acksid for fast lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a541a427940ee4da46578b914bb8e279e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void soap_wsrm_seq_insert_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to insert seq id in hash table for fast lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>sequence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c3ba7e98b20cc44d969e6c673c92a8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a>* soap_wsrm_seq_lookup </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to look up sequence given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence handle, must be released with <a class="el" href="wsrmapi_8c.html#a9340a192f64193f17e03666792016c63">soap_wsrm_seq_release</a> when no longer used </dd></dl>

</div>
</div>
<a class="anchor" id="aab3fb99b5475b570e23c421a067894fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_lookup_ack </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to look up sequence given its acksid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a15aa04e919fd1a0609363114efd4993d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> * soap_wsrm_seq_lookup_data </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to look up sequence given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence or NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a4cf30da78ce8219490ae6bf3419261c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a>* soap_wsrm_seq_lookup_id </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to look up sequence given its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identifier string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence handle, must be released with <a class="el" href="wsrmapi_8c.html#a9340a192f64193f17e03666792016c63">soap_wsrm_seq_release</a> when no longer used </dd></dl>

</div>
</div>
<a class="anchor" id="a557d4ee60557fe8a81a7500987135fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * soap_wsrm_seq_newid </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to generate a new sequence identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence identifier string </dd></dl>

</div>
</div>
<a class="anchor" id="a9340a192f64193f17e03666792016c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soap_wsrm_seq_release </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>sequence handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff4da9c5b03f165594e2d3d60dacbdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_seq_valid </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if a sequence is not valid, terminated, or needs to be terminated when expired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramname">seq</td><td>pointer to sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (invalid) or 1 (valid) </dd></dl>

</div>
</div>
<a class="anchor" id="a89e463cf47695a283b6c50d1bec26809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int soap_wsrm_set_ack </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG64&#160;</td>
          <td class="paramname"><em>nack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct__wsrm_____sequence_acknowledgement.html">_wsrm__SequenceAcknowledgement</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function called by <a class="el" href="wsrmapi_8c.html#aea7a9a67116baef61a5788136e809c7e" title="Internal function to add SequenceAcknowledgement headers for AckRequested. When piggy==0 or internal ...">soap_wsrm_add_acks()</a> to populate the SequenceAcknowledgement header block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nack</td><td>num of message to nack, 0 to pupulate ack with ranges from seq </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>pointer to sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ack</td><td>pointer to SequenceAcknowledgement to populate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed55a951561e63b74699003f423e6e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_terminate </td>
          <td>(</td>
          <td class="paramtype">struct soap *&#160;</td>
          <td class="paramname"><em>soap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wsa_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates the sequence. No new messages should be send and no resends should be tried. Usually done after <a class="el" href="wsrmapi_8h.html#a663e39e46e4fb291ee0f9af8a0badac5" title="Closes the sequence, but does not yet terminate it. No new messages should be send, but messages can be resend with soap_wsrm_resend() if desired.">soap_wsrm_close()</a> or any time to terminate the sequence prematurely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">soap</td><td>context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seq</td><td>sequence handle set by soap_wsrm_create or soap_wsrm_create_offer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wsa_id</td><td>WS-Addressing message ID (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SOAP_OK or error code </dd></dl>

</div>
</div>
<a class="anchor" id="af663ecef2b9b1c780a0dc39a1602ab08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* soap_wsrm_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="wsrmapi_8h.html#a881daeb2267f7765aeb13c1cf0d60c74">soap_wsrm_sequence_handle</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the endpoint address of the destination service that serves the sequence. Initially set with soap_wsrm_create or soap_wsrm_create_offer. HTTP 307 Temporary Redirect can change the endpoint during the lifetime of a message sequence. Thus, this function returns the most recent endpoint binding that can be used to send message to the server endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>sequence handle set by <a class="el" href="wsrmapi_8h.html#ae1351fd2ece8ddd1a8da40e7ebe6b36f" title="Creates a new sequence. Sequences are usually created by the sender (client) and confirmed by the rec...">soap_wsrm_create()</a> or <a class="el" href="wsrmapi_8h.html#a54cb27e4c3139e5197a30d15686cadca" title="Creates a new sequence by offering suggested WS-RM parameters to the WS-RM destination. Sequences are usually created by the sender (client) and confirmed by the receiver (server). The &#39;to&#39; server address must be used for all messages of the sequence to be sent to the WS-RM destination server. Optionally the &#39;replyto&#39; address can be given of the WS-RM source to reply to. A sequence ID is generated by the server upon success.">soap_wsrm_create_offer()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence endpoint address or replyTo address (when provided) or NULL when no destination is given </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a2f5b88f6da2708c658e230610ca380ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char soap_wsrm_id[] = <a class="el" href="wsrmapi_8h.html#a0578c988308fdba3053e1aee6885e94d">SOAP_WSRM_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plugin identification for plugin registry </p>

</div>
</div>
<a class="anchor" id="a64b413c93faa278f185f742ee8d1da4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char soap_wsrm_idname[40] = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29b7ed420cfa320543882a34238f55b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soap_wsrm_idnum = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b87a809162eab1f088457a69765dfa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsoap__wsrm__sequence.html">soap_wsrm_sequence</a>* soap_wsrm_session = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sequence session database </p>

</div>
</div>
<a class="anchor" id="a1f675d133185cc7a40b0af8e0d5ffdcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MUTEX_TYPE soap_wsrm_session_lock = MUTEX_INITIALIZER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sequence session database lock </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 4 2014 15:44:45 for gSOAP WS-ReliableMessaging by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
